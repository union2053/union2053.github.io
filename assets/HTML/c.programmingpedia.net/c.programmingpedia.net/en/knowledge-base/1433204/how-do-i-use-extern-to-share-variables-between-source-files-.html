<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/1433204/how-do-i-use-extern-to-share-variables-between-source-files- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:14:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="How do I use extern to share variables between source files? | C Language Knowledge Base">
        <meta name="description" property="og:description" content="How do I use extern to share variables between source files? | C Language Knowledge Base">
        <title>How do I use extern to share variables between source files? | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="how-do-i-use-extern-to-share-variables-between-source-files-">How do I use extern to share variables between source files?</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/extern.html">extern</a></span>
                        <span class="tag-item"><a href="../tag/global-variables.html">global-variables</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>I know that global variables in C sometimes have the <code>extern</code> keyword. What is an <code>extern</code> variable? What is the declaration like? What is its scope?</p>

<p>This is related to sharing variables across source files, but how does that work precisely? Where do I use <code>extern</code>?</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/0/shilpa" target="_blank"><span itemprop="name">shilpa</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">917</div>
                                    <div itemprop="dateCreated">5/22/2017 7:01:16 AM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question second-answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div itemprop="text">
                                        <p>Using <code>extern</code> is only of relevance when the program you're building
consists of multiple source files linked together, where some of the
variables defined, for example, in source file <code>file1.c</code> need to be
referenced in other source files, such as <code>file2.c</code>.</p>

<p>It is important to <a href="https://stackoverflow.com/questions/1410563">understand the difference between <em>defining</em> a
variable and <em>declaring</em> a
variable</a>:</p>

<ul>
<li>A variable is <strong>declared</strong> when the compiler is informed that a
variable exists (and this is its type); it does not allocate the
storage for the variable at that point.</li>
<li>A variable is <strong>defined</strong> when the compiler allocates the storage for
the variable.</li>
</ul>

<p>You may declare a variable multiple times (though once is sufficient);
you may only define it once within a given scope.
A variable definition is also a declaration, but not all variable
declarations are definitions.</p>

<h2 id="best-way-to-declare-and-define-global-variables">Best way to declare and define global variables</h2>

<p>The clean, reliable way to declare and define global variables is to use
a header file to contain an <code>extern</code> <em>declaration</em> of the variable.</p>

<p>The header is included by the one source file that defines the variable
and by all the source files that reference the variable.
For each program, one source file (and only one source file) defines the
variable.
Similarly, one header file (and only one header file) should declare the
variable.
The header file is crucial; it enables cross-checking between
independent TUs (translation units — think source files) and ensures
consistency.</p>

<p>Although there are other ways of doing it, this method is simple and
reliable.
It is demonstrated by <code>file3.h</code>, <code>file1.c</code> and <code>file2.c</code>:</p>

<h3 id="file3-h">file3.h</h3>

<pre><code>extern int global_variable;  /* Declaration of the variable */
</code></pre>

<h3 id="file1-c">file1.c</h3>

<pre><code>#include "file3.h"  /* Declaration made available here */
#include "prog1.h"  /* Function declarations */

/* Variable defined here */
int global_variable = 37;    /* Definition checked against declaration */

int increment(void) { return global_variable++; }
</code></pre>

<h3 id="file2-c">file2.c</h3>

<pre><code>#include "file3.h"
#include "prog1.h"
#include &lt;stdio.h&gt;

void use_it(void)
{
    printf("Global variable: %d\n", global_variable++);
}
</code></pre>

<p>That's the best way to declare and define global variables.</p>

<hr>

<p><em>The next two files complete the source for <code>prog1</code>:</em></p>

<p>The complete programs shown use functions, so function declarations have
crept in.
Both C99 and C11 require functions to be declared or defined before they
are used (whereas C90 did not, for good reasons).
I use the keyword <code>extern</code> in front of function declarations in headers
for consistency — to match the <code>extern</code> in front of variable
declarations in headers.
Many people prefer not to use <code>extern</code> in front of function
declarations; the compiler doesn't care — and ultimately, neither do I
as long as you're consistent, at least within a source file.</p>

<h3 id="prog1-h">prog1.h</h3>

<pre><code>extern void use_it(void);
extern int increment(void);
</code></pre>

<h3 id="prog1-c">prog1.c</h3>

<pre><code>#include "file3.h"
#include "prog1.h"
#include &lt;stdio.h&gt;

int main(void)
{
    use_it();
    global_variable += 19;
    use_it();
    printf("Increment: %d\n", increment());
    return 0;
}
</code></pre>

<ul>
<li><code>prog1</code> uses <code>prog1.c</code>, <code>file1.c</code>, <code>file2.c</code>, <code>file3.h</code> and <code>prog1.h</code>.</li>
</ul>

<p>The file <code>prog1.mk</code> is a makefile for <code>prog1</code> only.
It will work with most versions of <code>make</code> produced since about the turn
of the millennium.
It is not tied specifically to GNU Make.</p>

<h3 id="prog1-mk">prog1.mk</h3>

<pre><code># Minimal makefile for prog1

PROGRAM = prog1
FILES.c = prog1.c file1.c file2.c
FILES.h = prog1.h file3.h
FILES.o = ${FILES.c:.c=.o}

CC      = gcc
SFLAGS  = -std=c11
GFLAGS  = -g
OFLAGS  = -O3
WFLAG1  = -Wall
WFLAG2  = -Wextra
WFLAG3  = -Werror
WFLAG4  = -Wstrict-prototypes
WFLAG5  = -Wmissing-prototypes
WFLAGS  = ${WFLAG1} ${WFLAG2} ${WFLAG3} ${WFLAG4} ${WFLAG5}
UFLAGS  = # Set on command line only

CFLAGS  = ${SFLAGS} ${GFLAGS} ${OFLAGS} ${WFLAGS} ${UFLAGS}
LDFLAGS =
LDLIBS  =

all:    ${PROGRAM}

${PROGRAM}: ${FILES.o}
    ${CC} -o $@ ${CFLAGS} ${FILES.o} ${LDFLAGS} ${LDLIBS}

prog1.o: ${FILES.h}
file1.o: ${FILES.h}
file2.o: ${FILES.h}

# If it exists, prog1.dSYM is a directory on macOS
DEBRIS = a.out core *~ *.dSYM
RM_FR  = rm -fr

clean:
    ${RM_FR} ${FILES.o} ${PROGRAM} ${DEBRIS}
</code></pre>

<hr>

<h2 id="guidelines">Guidelines</h2>

<p>Rules to be broken by experts only, and only with good reason:</p>

<ul>
<li>A header file only contains <code>extern</code> declarations of variables — never
<code>static</code> or unqualified variable definitions.</li>
<li>For any given variable, only one header file declares it (SPOT —
Single Point of Truth).</li>
<li>A source file never contains <code>extern</code> declarations of variables —
source files always include the (sole) header that declares them.</li>
<li>For any given variable, exactly one source file defines the variable,
preferably initializing it too.  (Although there is no need to
initialize explicitly to zero, it does no harm and can do some good,
because there can be only one initialized definition of a particular
global variable in a program).</li>
<li>The source file that defines the variable also includes the header to
ensure that the definition and the declaration are consistent.</li>
<li>A function should never need to declare a variable using <code>extern</code>.</li>
<li>Avoid global variables whenever possible — use functions instead.</li>
</ul>

<p><sup><em>The source code and text of this answer are available in my
      <a href="https://github.com/jleffler/soq" rel="noreferrer">SOQ</a> (Stack Overflow Questions)
      repository on GitHub in the
      <a href="https://github.com/jleffler/soq/tree/master/src/so-0143-3204" rel="noreferrer">src/so-0143-3204</a>
      sub-directory.</em>
</sup></p>

<p><sup><em>If you're not an experienced C programmer, you could (and perhaps
       should) stop reading here.</em>
</sup></p>

<h2 id="not-so-good-way-to-define-global-variables">Not so good way to define global variables</h2>

<p>With some (indeed, many) C compilers, you can get away with what's
called a 'common' definition of a variable too.
'Common', here, refers to a technique used in Fortran for sharing
variables between source files, using a (possibly named) COMMON block.
What happens here is that each of a number of files provides a tentative
definition of the variable.
As long as no more than one file provides an initialized definition,
then the various files end up sharing a common single definition of the
variable:</p>

<h3 id="file10-c">file10.c</h3>

<pre><code>#include "prog2.h"

int i;   /* Do not do this in portable code */

void inc(void) { i++; }
</code></pre>

<h3 id="file11-c">file11.c</h3>

<pre><code>#include "prog2.h"

int i;   /* Do not do this in portable code */

void dec(void) { i--; }
</code></pre>

<h3 id="file12-c">file12.c</h3>

<pre><code>#include "prog2.h"
#include &lt;stdio.h&gt;

int i = 9;   /* Do not do this in portable code */

void put(void) { printf("i = %d\n", i); }
</code></pre>

<p>This technique does not conform to the letter of the C standard and the
'one definition rule' — it is officially undefined behaviour:</p>

<blockquote>
  <p><strong><a href="http://port70.net/~nsz/c/c11/n1570.html#J.2" rel="noreferrer">J.2 Undefined behavior</a></strong></p>
  
  <p>An identifier with external linkage is used, but in the program there
  does not exist exactly one external definition for the identifier, or
  the identifier is not used and there exist multiple external
  definitions for the identifier (6.9).</p>
  
  <p><strong><a href="http://port70.net/~nsz/c/c11/n1570.html#6.9p5" rel="noreferrer">§6.9 External definitions ¶5</a></strong></p>
  
  <p>An <em>external definition</em> is an external declaration that is also a
  definition of a function (other than an inline definition) or an
  object.
  If an identifier declared with external linkage is used in an
  expression (other than as part of the operand of a <code>sizeof</code> or
  <code>_Alignof</code> operator whose result is an integer constant), somewhere in
  the entire program there shall be exactly one external definition for
  the identifier; otherwise, there shall be no more than
  one.<sup>161)</sup></p>
  
  <p><sup>161)</sup> Thus, if an identifier declared with external linkage
  is not used in an expression, there need be no external definition for
  it.</p>
</blockquote>

<p>However, the C standard also lists it in informative Annex J as one of
the <a href="http://port70.net/~nsz/c/c11/n1570.html#J.5" rel="noreferrer">Common extensions</a>.</p>

<blockquote>
  <p><a href="http://port70.net/~nsz/c/c11/n1570.html#J.5.11" rel="noreferrer">J.5.11 Multiple external definitions</a></p>
  
  <p>There may be more than one external definition for the identifier of
  an object, with or without the explicit use of the keyword extern; if
  the definitions disagree, or more than one is initialized, the
  behavior is undefined (6.9.2).</p>
</blockquote>

<p>Because this technique is not always supported, it is best to avoid
using it, <em>especially if your code needs to be portable</em>.
Using this technique, you can also end up with unintentional type
punning.
If one of the files declared <code>i</code> as a <code>double</code> instead of as an <code>int</code>,
C's type-unsafe linkers probably would not spot the mismatch.
If you're on a machine with 64-bit <code>int</code> and <code>double</code>, you'd not even
get a warning; on a machine with 32-bit <code>int</code> and 64-bit <code>double</code>, you'd
probably get a warning about the different sizes — the linker would
use the largest size, exactly as a Fortran program would take the
largest size of any common blocks.</p>

<hr>

<p><em>The next two files complete the source for <code>prog2</code>:</em></p>

<h3 id="prog2-h">prog2.h</h3>

<pre><code>extern void dec(void);
extern void put(void);
extern void inc(void);
</code></pre>

<h3 id="prog2-c">prog2.c</h3>

<pre><code>#include "prog2.h"
#include &lt;stdio.h&gt;

int main(void)
{
    inc();
    put();
    dec();
    put();
    dec();
    put();
}
</code></pre>

<ul>
<li><code>prog2</code> uses <code>prog2.c</code>, <code>file10.c</code>, <code>file11.c</code>, <code>file12.c</code>, <code>prog2.h</code>.</li>
</ul>

<hr>

<h3 id="warning">Warning</h3>

<p>As noted in comments here, and as stated in my answer to a similar
<a href="https://stackoverflow.com/questions/1490693">question</a>, using multiple
definitions for a global variable leads to undefined behaviour (J.2;
§6.9), which is the standard's way of saying "anything could happen".
One of the things that can happen is that the program behaves as you
expect; and J.5.11 says, approximately, "you might be lucky more often
than you deserve".
But a program that relies on multiple definitions of an extern variable
— with or without the explicit 'extern' keyword — is not a strictly
conforming program and not guaranteed to work everywhere.
Equivalently: it contains a bug which may or may not show itself.</p>

<h2 id="violating-the-guidelines">Violating the guidelines</h2>

<p>There are, of course, many ways in which these guidelines can be broken.
Occasionally, there may be a good reason to break the guidelines, but
such occasions are extremely unusual.</p>

<h3 id="faulty-header-h">faulty_header.h</h3>

<pre><code>int some_var;    /* Do not do this in a header!!! */
</code></pre>

<p>Note 1: if the header defines the variable without the <code>extern</code> keyword,
then each file that includes the header creates a tentative definition
of the variable.
As noted previously, this will often work, but the C standard does not
guarantee that it will work.</p>

<h3 id="broken-header-h">broken_header.h</h3>

<pre><code>int some_var = 13;    /* Only one source file in a program can use this */
</code></pre>

<p>Note 2: if the header defines and initializes the variable, then only
one source file in a given program can use the header.
Since headers are primarily for sharing information, it is a bit silly
to create one that can only be used once.</p>

<h3 id="seldom-correct-h">seldom_correct.h</h3>

<pre><code>static int hidden_global = 3;   /* Each source file gets its own copy  */
</code></pre>

<p>Note 3: if the header defines a static variable (with or without
initialization), then each source file ends up with its own private
version of the 'global' variable.</p>

<p>If the variable is actually a complex array, for example, this can lead
to extreme duplication of code.  It can, very occasionally, be a
sensible way to achieve some effect, but that is very unusual.</p>

<hr>

<h2 id="summary">Summary</h2>

<p>Use the header technique I showed first.
It works reliably and everywhere.
Note, in particular, that the header declaring the <code>global_variable</code> is
included in every file that uses it — including the one that defines it.
This ensures that everything is self-consistent.</p>

<p>Similar concerns arise with declaring and defining functions —
analogous rules apply.
But the question was about variables specifically, so I've kept the
answer to variables only.</p>

<h3 id="end-of-original-answer">End of Original Answer</h3>

<p><sup><em>If you're not an experienced C programmer, you probably should stop reading here.</em></sup></p>

<hr>

<p><em>Late Major Addition</em></p>

<h1 id="avoiding-code-duplication">Avoiding Code Duplication</h1>

<p>One concern that is sometimes (and legitimately) raised about the
'declarations in headers, definitions in source' mechanism described
here is that there are two files to be kept synchronized — the header
and the source.  This is usually followed up with an observation that a
macro can be used so that the header serves double duty — normally
declaring the variables, but when a specific macro is set before the
header is included, it defines the variables instead.</p>

<p>Another concern can be that the variables need to be defined in each of
a number of 'main programs'.  This is normally a spurious concern; you
can simply introduce a C source file to define the variables and link
the object file produced with each of the programs.</p>

<p>A typical scheme works like this, using the original global variable
illustrated in <code>file3.h</code>:</p>

<h3 id="file3a-h">file3a.h</h3>

<pre><code>#ifdef DEFINE_VARIABLES
#define EXTERN /* nothing */
#else
#define EXTERN extern
#endif /* DEFINE_VARIABLES */

EXTERN int global_variable;
</code></pre>

<h3 id="file1a-c">file1a.c</h3>

<pre><code>#define DEFINE_VARIABLES
#include "file3a.h"  /* Variable defined - but not initialized */
#include "prog3.h"

int increment(void) { return global_variable++; }
</code></pre>

<h3 id="file2a-c">file2a.c</h3>

<pre><code>#include "file3a.h"
#include "prog3.h"
#include &lt;stdio.h&gt;

void use_it(void)
{
    printf("Global variable: %d\n", global_variable++);
}
</code></pre>

<hr>

<p><em>The next two files complete the source for <code>prog3</code>:</em></p>

<h3 id="prog3-h">prog3.h</h3>

<pre><code>extern void use_it(void);
extern int increment(void);
</code></pre>

<h3 id="prog3-c">prog3.c</h3>

<pre><code>#include "file3a.h"
#include "prog3.h"
#include &lt;stdio.h&gt;

int main(void)
{
    use_it();
    global_variable += 19;
    use_it();
    printf("Increment: %d\n", increment());
    return 0;
}
</code></pre>

<ul>
<li><code>prog3</code> uses <code>prog3.c</code>, <code>file1a.c</code>, <code>file2a.c</code>, <code>file3a.h</code>, <code>prog3.h</code>.</li>
</ul>

<hr>

<h2 id="variable-initialization">Variable initialization</h2>

<p>The problem with this scheme as shown is that it does not provide for
initialization of the global variable.  With C99 or C11 and variable argument
lists for macros, you could define a macro to support initialization too.
(With C89 and no support for variable argument lists in macros, there is no
easy way to handle arbitrarily long initializers.)</p>

<h3 id="file3b-h">file3b.h</h3>

<pre><code>#ifdef DEFINE_VARIABLES
#define EXTERN                  /* nothing */
#define INITIALIZER(...)        = __VA_ARGS__
#else
#define EXTERN                  extern
#define INITIALIZER(...)        /* nothing */
#endif /* DEFINE_VARIABLES */

EXTERN int global_variable INITIALIZER(37);
EXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });
</code></pre>

<p><sup>Reverse contents of <code>#if</code> and <code>#else</code> blocks, fixing bug identified by
<a href="https://stackoverflow.com/users/369317/denis-kniazhev">Denis Kniazhev</a></sup></p>

<h3 id="file1b-c">file1b.c</h3>

<pre><code>#define DEFINE_VARIABLES
#include "file3b.h"  /* Variables now defined and initialized */
#include "prog4.h"

int increment(void) { return global_variable++; }
int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
</code></pre>

<h3 id="file2b-c">file2b.c</h3>

<pre><code>#include "file3b.h"
#include "prog4.h"
#include &lt;stdio.h&gt;

void use_them(void)
{
    printf("Global variable: %d\n", global_variable++);
    oddball_struct.a += global_variable;
    oddball_struct.b -= global_variable / 2;
}
</code></pre>

<p>Clearly, the code for the oddball structure is not what you'd normally
write, but it illustrates the point.  The first argument to the second
invocation of <code>INITIALIZER</code> is <code>{ 41</code> and the remaining argument
(singular in this example) is <code>43 }</code>.  Without C99 or similar support
for variable argument lists for macros, initializers that need to
contain commas are very problematic.</p>

<p><sup>Correct header <code>file3b.h</code> included (instead of <code>fileba.h</code>) per
<a href="https://stackoverflow.com/users/369317/denis-kniazhev">Denis Kniazhev</a></sup></p>

<hr>

<p><em>The next two files complete the source for <code>prog4</code>:</em></p>

<h3 id="prog4-h">prog4.h</h3>

<pre><code>extern int increment(void);
extern int oddball_value(void);
extern void use_them(void);
</code></pre>

<h3 id="prog4-c">prog4.c</h3>

<pre><code>#include "file3b.h"
#include "prog4.h"
#include &lt;stdio.h&gt;

int main(void)
{
    use_them();
    global_variable += 19;
    use_them();
    printf("Increment: %d\n", increment());
    printf("Oddball:   %d\n", oddball_value());
    return 0;
}
</code></pre>

<ul>
<li><code>prog4</code> uses <code>prog4.c</code>, <code>file1b.c</code>, <code>file2b.c</code>, <code>prog4.h</code>, <code>file3b.h</code>.</li>
</ul>

<hr>

<h2 id="header-guards">Header Guards</h2>

<p>Any header should be protected against reinclusion, so that type
definitions (enum, struct or union types, or typedefs generally) do not
cause problems.  The standard technique is to wrap the body of the
header in a header guard such as:</p>

<pre><code>#ifndef FILE3B_H_INCLUDED
#define FILE3B_H_INCLUDED

...contents of header...

#endif /* FILE3B_H_INCLUDED */
</code></pre>

<p>The header might be included twice indirectly.  For example, if
<code>file4b.h</code> includes <code>file3b.h</code> for a type definition that isn't shown,
and <code>file1b.c</code> needs to use both header <code>file4b.h</code> and <code>file3b.h</code>, then
you have some more tricky issues to resolve.  Clearly, you might revise
the header list to include just <code>file4b.h</code>.  However, you might not be
aware of the internal dependencies — and the code should, ideally,
continue to work.</p>

<p>Further, it starts to get tricky because you might include <code>file4b.h</code>
before including <code>file3b.h</code> to generate the definitions, but the normal
header guards on <code>file3b.h</code> would prevent the header being reincluded.</p>

<p>So, you need to include the body of <code>file3b.h</code> at most once for
declarations, and at most once for definitions, but you might need both
in a single translation unit (TU — a combination of a source file and
the headers it uses).</p>

<h2 id="multiple-inclusion-with-variable-definitions">Multiple inclusion with variable definitions</h2>

<p>However, it can be done subject to a not too unreasonable constraint.
Let's introduce a new set of file names:</p>

<ul>
<li><code>external.h</code> for the EXTERN macro definitions, etc.</li>
<li><code>file1c.h</code> to define types (notably, <code>struct oddball</code>, the type of <code>oddball_struct</code>).</li>
<li><code>file2c.h</code> to define or declare the global variables.</li>
<li><code>file3c.c</code> which defines the global variables.</li>
<li><code>file4c.c</code> which simply uses the global variables.</li>
<li><code>file5c.c</code> which shows that you can declare and then define the global variables.</li>
<li><code>file6c.c</code> which shows that you can define and then (attempt to) declare the global variables.</li>
</ul>

<p>In these examples, <code>file5c.c</code> and <code>file6c.c</code> directly include the header
<code>file2c.h</code> several times, but that is the simplest way to show that the
mechanism works.  It means that if the header was indirectly included
twice, it would also be safe.</p>

<p>The restrictions for this to work are:</p>

<ol>
<li>The header defining or declaring the global variables may not itself
define any types.</li>
<li>Immediately before you include a header that should define variables,
you define the macro DEFINE_VARIABLES.</li>
<li>The header defining or declaring the variables has stylized contents.</li>
</ol>

<h3 id="external-h">external.h</h3>

<pre><code>/*
** This header must not contain header guards (like &lt;assert.h&gt; must not).
** Each time it is invoked, it redefines the macros EXTERN, INITIALIZE
** based on whether macro DEFINE_VARIABLES is currently defined.
*/
#undef EXTERN
#undef INITIALIZE

#ifdef DEFINE_VARIABLES
#define EXTERN              /* nothing */
#define INITIALIZE(...)     = __VA_ARGS__
#else
#define EXTERN              extern
#define INITIALIZE(...)     /* nothing */
#endif /* DEFINE_VARIABLES */
</code></pre>

<h3 id="file1c-h">file1c.h</h3>

<pre><code>#ifndef FILE1C_H_INCLUDED
#define FILE1C_H_INCLUDED

struct oddball
{
    int a;
    int b;
};

extern void use_them(void);
extern int increment(void);
extern int oddball_value(void);

#endif /* FILE1C_H_INCLUDED */
</code></pre>

<h3 id="file2c-h">file2c.h</h3>

<pre><code>/* Standard prologue */
#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2C_H_DEFINITIONS)
#undef FILE2C_H_INCLUDED
#endif

#ifndef FILE2C_H_INCLUDED
#define FILE2C_H_INCLUDED

#include "external.h"   /* Support macros EXTERN, INITIALIZE */
#include "file1c.h"     /* Type definition for struct oddball */

#if !defined(DEFINE_VARIABLES) || !defined(FILE2C_H_DEFINITIONS)

/* Global variable declarations / definitions */
EXTERN int global_variable INITIALIZE(37);
EXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });

#endif /* !DEFINE_VARIABLES || !FILE2C_H_DEFINITIONS */

/* Standard epilogue */
#ifdef DEFINE_VARIABLES
#define FILE2C_H_DEFINITIONS
#endif /* DEFINE_VARIABLES */

#endif /* FILE2C_H_INCLUDED */
</code></pre>

<h3 id="file3c-c">file3c.c</h3>

<pre><code>#define DEFINE_VARIABLES
#include "file2c.h"  /* Variables now defined and initialized */

int increment(void) { return global_variable++; }
int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
</code></pre>

<h3 id="file4c-c">file4c.c</h3>

<pre><code>#include "file2c.h"
#include &lt;stdio.h&gt;

void use_them(void)
{
    printf("Global variable: %d\n", global_variable++);
    oddball_struct.a += global_variable;
    oddball_struct.b -= global_variable / 2;
}
</code></pre>

<h3 id="file5c-c">file5c.c</h3>

<pre><code>#include "file2c.h"     /* Declare variables */

#define DEFINE_VARIABLES
#include "file2c.h"  /* Variables now defined and initialized */

int increment(void) { return global_variable++; }
int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
</code></pre>

<h3 id="file6c-c">file6c.c</h3>

<pre><code>#define DEFINE_VARIABLES
#include "file2c.h"     /* Variables now defined and initialized */

#include "file2c.h"     /* Declare variables */

int increment(void) { return global_variable++; }
int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
</code></pre>

<hr>

<p><em>The next source file completes the source (provides a main program) for <code>prog5</code>, <code>prog6</code> and <code>prog7</code>:</em></p>

<h3 id="prog5-c">prog5.c</h3>

<pre><code>#include "file2c.h"
#include &lt;stdio.h&gt;

int main(void)
{
    use_them();
    global_variable += 19;
    use_them();
    printf("Increment: %d\n", increment());
    printf("Oddball:   %d\n", oddball_value());
    return 0;
}
</code></pre>

<ul>
<li><code>prog5</code> uses <code>prog5.c</code>, <code>file3c.c</code>, <code>file4c.c</code>, <code>file1c.h</code>, <code>file2c.h</code>, <code>external.h</code>.</li>
<li><code>prog6</code> uses <code>prog5.c</code>, <code>file5c.c</code>, <code>file4c.c</code>, <code>file1c.h</code>, <code>file2c.h</code>, <code>external.h</code>.</li>
<li><code>prog7</code> uses <code>prog5.c</code>, <code>file6c.c</code>, <code>file4c.c</code>, <code>file1c.h</code>, <code>file2c.h</code>, <code>external.h</code>.</li>
</ul>

<hr>

<p>This scheme avoids most problems.  You only run into a problem if a
header that defines variables (such as <code>file2c.h</code>) is included by
another header (say <code>file7c.h</code>) that defines variables.  There isn't an
easy way around that other than "don't do it".</p>

<p>You can partially work around the problem by revising <code>file2c.h</code> into
<code>file2d.h</code>:</p>

<h3 id="file2d-h">file2d.h</h3>

<pre><code>/* Standard prologue */
#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2D_H_DEFINITIONS)
#undef FILE2D_H_INCLUDED
#endif

#ifndef FILE2D_H_INCLUDED
#define FILE2D_H_INCLUDED

#include "external.h"   /* Support macros EXTERN, INITIALIZE */
#include "file1c.h"     /* Type definition for struct oddball */

#if !defined(DEFINE_VARIABLES) || !defined(FILE2D_H_DEFINITIONS)

/* Global variable declarations / definitions */
EXTERN int global_variable INITIALIZE(37);
EXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });

#endif /* !DEFINE_VARIABLES || !FILE2D_H_DEFINITIONS */

/* Standard epilogue */
#ifdef DEFINE_VARIABLES
#define FILE2D_H_DEFINITIONS
#undef DEFINE_VARIABLES
#endif /* DEFINE_VARIABLES */

#endif /* FILE2D_H_INCLUDED */
</code></pre>

<p>The issue becomes 'should the header include <code>#undef DEFINE_VARIABLES</code>?'
If you omit that from the header and wrap any defining invocation with
<code>#define</code> and <code>#undef</code>:</p>

<pre><code>#define DEFINE_VARIABLES
#include "file2c.h"
#undef DEFINE_VARIABLES
</code></pre>

<p>in the source code (so the headers never alter the value of
<code>DEFINE_VARIABLES</code>), then you should be clean.  It is just a nuisance to
have to remember to write the the extra line.  An alternative might be:</p>

<pre><code>#define HEADER_DEFINING_VARIABLES "file2c.h"
#include "externdef.h"
</code></pre>

<h3 id="externdef-h">externdef.h</h3>

<pre><code>/*
** This header must not contain header guards (like &lt;assert.h&gt; must not).
** Each time it is included, the macro HEADER_DEFINING_VARIABLES should
** be defined with the name (in quotes - or possibly angle brackets) of
** the header to be included that defines variables when the macro
** DEFINE_VARIABLES is defined.  See also: external.h (which uses
** DEFINE_VARIABLES and defines macros EXTERN and INITIALIZE
** appropriately).
**
** #define HEADER_DEFINING_VARIABLES "file2c.h"
** #include "externdef.h"
*/

#if defined(HEADER_DEFINING_VARIABLES)
#define DEFINE_VARIABLES
#include HEADER_DEFINING_VARIABLES
#undef DEFINE_VARIABLES
#undef HEADER_DEFINING_VARIABLES
#endif /* HEADER_DEFINING_VARIABLES */
</code></pre>

<p>This is getting a tad convoluted, but seems to be secure (using the
<code>file2d.h</code>, with no <code>#undef DEFINE_VARIABLES</code> in the <code>file2d.h</code>).</p>

<h3 id="file7c-c">file7c.c</h3>

<pre><code>/* Declare variables */
#include "file2d.h"

/* Define variables */
#define HEADER_DEFINING_VARIABLES "file2d.h"
#include "externdef.h"

/* Declare variables - again */
#include "file2d.h"

/* Define variables - again */
#define HEADER_DEFINING_VARIABLES "file2d.h"
#include "externdef.h"

int increment(void) { return global_variable++; }
int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
</code></pre>

<h3 id="file8c-h">file8c.h</h3>

<pre><code>/* Standard prologue */
#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE8C_H_DEFINITIONS)
#undef FILE8C_H_INCLUDED
#endif

#ifndef FILE8C_H_INCLUDED
#define FILE8C_H_INCLUDED

#include "external.h"   /* Support macros EXTERN, INITIALIZE */
#include "file2d.h"     /* struct oddball */

#if !defined(DEFINE_VARIABLES) || !defined(FILE8C_H_DEFINITIONS)

/* Global variable declarations / definitions */
EXTERN struct oddball another INITIALIZE({ 14, 34 });

#endif /* !DEFINE_VARIABLES || !FILE8C_H_DEFINITIONS */

/* Standard epilogue */
#ifdef DEFINE_VARIABLES
#define FILE8C_H_DEFINITIONS
#endif /* DEFINE_VARIABLES */

#endif /* FILE8C_H_INCLUDED */
</code></pre>

<h3 id="file8c-c">file8c.c</h3>

<pre><code>/* Define variables */
#define HEADER_DEFINING_VARIABLES "file2d.h"
#include "externdef.h"

/* Define variables */
#define HEADER_DEFINING_VARIABLES "file8c.h"
#include "externdef.h"

int increment(void) { return global_variable++; }
int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
</code></pre>

<hr>

<p><em>The next two files complete the source for <code>prog8</code> and <code>prog9</code>:</em></p>

<h3 id="prog8-c">prog8.c</h3>

<pre><code>#include "file2d.h"
#include &lt;stdio.h&gt;

int main(void)
{
    use_them();
    global_variable += 19;
    use_them();
    printf("Increment: %d\n", increment());
    printf("Oddball:   %d\n", oddball_value());
    return 0;
}
</code></pre>

<h3 id="file9c-c">file9c.c</h3>

<pre><code>#include "file2d.h"
#include &lt;stdio.h&gt;

void use_them(void)
{
    printf("Global variable: %d\n", global_variable++);
    oddball_struct.a += global_variable;
    oddball_struct.b -= global_variable / 2;
}
</code></pre>

<ul>
<li><code>prog8</code> uses <code>prog8.c</code>, <code>file7c.c</code>, <code>file9c.c</code>.</li>
<li><code>prog9</code> uses <code>prog8.c</code>, <code>file8c.c</code>, <code>file9c.c</code>.</li>
</ul>

<hr>

<p>However, the problems are relatively unlikely to occur in practice,
especially if you take the standard advice to</p>

<h1 id="avoid-global-variables">Avoid global variables</h1>

<hr>

<p>Does this exposition miss anything?</p>

<p><em>Confession</em>: The 'avoiding duplicated code' scheme outlined here was
developed because the issue affects some code I work on (but don't own),
and is a niggling concern with the scheme outlined in the first part of
the answer.  However, the original scheme leaves you with just two
places to modify to keep variable definitions and declarations
synchronized, which is a big step forward over having exernal variable
declarations scattered throughout the code base (which really matters
when there are thousands of files in total).  However, the code in the
files with the names <code>fileNc.[ch]</code> (plus <code>external.h</code> and <code>externdef.h</code>)
shows that it can be made to work.  Clearly, it would not be hard to
create a header generator script to give you the standardized template
for a variable defining and declaring header file.</p>

<p><em>NB</em> These are toy programs with just barely enough code to make them
marginally interesting.  There is repetition within the examples that
could be removed, but isn't to simplify the pedagogical explanation.
(For example: the difference between <code>prog5.c</code> and <code>prog8.c</code> is the name
of one of the headers that are included.  It would be possible to
reorganize the code so that the <code>main()</code> function was not repeated, but
it would conceal more than it revealed.)</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/15168/jonathan-leffler" target="_blank"><span itemprop="name">Jonathan Leffler</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/1433204/how-do-i-use-extern-to-share-variables-between-source-files-#answer-0</div>
                                            <div itemprop="upvoteCount">1648</div>
                                            <div itemprop="dateCreated">7/3/2018 4:04:34 PM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/1433204" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/1433204/how-do-i-use-extern-to-share-variables-between-source-files- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:14:33 GMT -->
</html>
