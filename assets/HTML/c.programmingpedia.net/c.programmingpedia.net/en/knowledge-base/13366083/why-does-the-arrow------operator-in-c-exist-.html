<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/13366083/why-does-the-arrow------operator-in-c-exist- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="[SOLVED] Why does the arrow (-&gt;) operator in C exist? | C Language Knowledge Base">
        <meta name="description" property="og:description" content="[SOLVED] Why does the arrow (-&gt;) operator in C exist? | C Language Knowledge Base">
        <title>[SOLVED] Why does the arrow (-&gt;) operator in C exist? | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="why-does-the-arrow-operator-in-c-exist-">Why does the arrow (->) operator in C exist?</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/dereference.html">dereference</a></span>
                        <span class="tag-item"><a href="../tag/pointers.html">pointers</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>The dot (<code>.</code>) operator is used to access a member of a struct, while the arrow operator (<code>-&gt;</code>) in C is used to access a member of a struct which is referenced by the pointer in question.</p>

<p>The pointer itself does not have any members which could be accessed with the dot operator (it's actually only a number describing a location in virtual memory so it doesn't have any members). So, there would be no ambiguity if we just defined the dot operator to automatically dereference the pointer if it is used on a pointer (an information which is known to the compiler at compile time afaik).</p>

<p>So why have the language creators decided to make things more complicated by adding this seemingly unnecessary operator? What is the big design decision?</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/1753601/askaga" target="_blank"><span itemprop="name">Askaga</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">243</div>
                                    <div itemprop="dateCreated">12/3/2014 3:02:38 AM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="accepted-answer">Accepted Answer</h3>
                                    <div itemprop="text">
                                        <p>I'll interpret your question as two questions: 1) why <code>-&gt;</code> even exists, and 2) why <code>.</code> does not automatically dereference the pointer. Answers to both questions have historical roots.</p>

<p><strong>Why does <code>-&gt;</code> even exist?</strong></p>

<p>In one of the very first versions of C language (which I will refer as CRM for "<a href="https://www.bell-labs.com/usr/dmr/www/cman.pdf" rel="noreferrer">C Reference Manual</a>", which came with 6th Edition Unix in May 1975), operator <code>-&gt;</code> had very exclusive meaning, not synonymous with <code>*</code> and <code>.</code> combination</p>

<p>The C language described by CRM was very different from the modern C in many respects. In CRM struct members implemented the global concept of <em>byte offset</em>, which could be added to any address value with no type restrictions. I.e. all names of all struct members had independent global meaning (and, therefore, had to be unique). For example you could declare</p>

<pre><code>struct S {
  int a;
  int b;
};
</code></pre>

<p>and name <code>a</code> would stand for offset 0, while name <code>b</code> would stand for offset 2 (assuming <code>int</code> type of size 2 and no padding). The language required all members of all structs in the translation unit either have unique names or stand for the same offset value. E.g. in the same translation unit you could additionally declare</p>

<pre><code>struct X {
  int a;
  int x;
};
</code></pre>

<p>and that would be OK, since the name <code>a</code> would consistently stand for offset 0. But this additional declaration</p>

<pre><code>struct Y {
  int b;
  int a;
};
</code></pre>

<p>would be formally invalid, since it attempted to "redefine" <code>a</code> as offset 2 and <code>b</code> as offset 0.</p>

<p>And this is where the <code>-&gt;</code> operator comes in. Since every struct member name had its own self-sufficient global meaning, the language supported expressions like these</p>

<pre><code>int i = 5;
i-&gt;b = 42;  /* Write 42 into `int` at address 7 */
100-&gt;a = 0; /* Write 0 into `int` at address 100 */
</code></pre>

<p>The first assignment was interpreted by the compiler as "take address <code>5</code>, add offset <code>2</code> to it and assign <code>42</code> to the <code>int</code> value at the resultant address". I.e. the above would assign <code>42</code> to <code>int</code> value at address <code>7</code>. Note that this use of <code>-&gt;</code> did not care about the type of the expression on the left-hand side. The left hand side was interpreted as an rvalue numerical address (be it a pointer or an integer).</p>

<p>This sort of trickery was not possible with <code>*</code> and <code>.</code> combination. You could not do</p>

<pre><code>(*i).b = 42;
</code></pre>

<p>since <code>*i</code> is already an invalid expression. The <code>*</code> operator, since it is separate from <code>.</code>, imposes more strict type requirements on its operand. To provide a capability to work around this limitation CRM introduced the <code>-&gt;</code> operator, which is independent from the type of the left-hand operand.</p>

<p>As Keith noted in the comments, this difference between <code>-&gt;</code> and <code>*</code>+<code>.</code> combination is what CRM is referring to as "relaxation of the requirement" in 7.1.8: <em>Except for the relaxation of the requirement that <code>E1</code> be of pointer type, the expression <code>E1−&gt;MOS</code> is exactly equivalent to <code>(*E1).MOS</code></em></p>

<p>Later, in K&amp;R C many features originally described in CRM were significantly reworked. The idea of "struct member as global offset identifier" was completely removed. And the functionality of <code>-&gt;</code> operator became fully identical to the functionality of <code>*</code> and <code>.</code> combination.</p>

<p><strong>Why can't <code>.</code> dereference the pointer automatically?</strong></p>

<p>Again, in CRM version of the language the left operand of the <code>.</code> operator was required to be an <em>lvalue</em>. That was the <em>only</em> requirement imposed on that operand (and that's what made it different from <code>-&gt;</code>, as explained above). Note that CRM did <em>not</em> require the left operand of <code>.</code> to have a struct type. It just required it to be an lvalue, <em>any</em> lvalue. This means that in CRM version of C you could write code like this</p>

<pre><code>struct S { int a, b; };
struct T { float x, y, z; };

struct T c;
c.b = 55;
</code></pre>

<p>In this case the compiler would write <code>55</code> into an <code>int</code> value positioned at byte-offset 2 in the continuous memory block known as <code>c</code>, even though type <code>struct T</code> had no field named <code>b</code>. The compiler would not care about the actual type of <code>c</code> at all. All it cared about is that <code>c</code> was an lvalue: some sort of writable memory block. </p>

<p>Now note that if you did this</p>

<pre><code>S *s;
...
s.b = 42;
</code></pre>

<p>the code would be considered valid (since <code>s</code> is also an lvalue) and the compiler would simply attempt to write data <em>into the pointer <code>s</code> itself</em>, at byte-offset 2. Needless to say, things like this could easily result in memory overrun, but the language did not concern itself with such matters.</p>

<p>I.e. in that version of the language your proposed idea about overloading operator <code>.</code> for pointer types would not work: operator <code>.</code> already had very specific meaning when used with pointers (with lvalue pointers or with any lvalues at all). It was very weird functionality, no doubt. But it was there at the time.</p>

<p>Of course, this weird functionality is not a very strong reason against introducing overloaded <code>.</code> operator for pointers (as you suggested) in the reworked version of C - K&amp;R C. But it hasn't been done. Maybe at that time there was some legacy code written in CRM version of C that had to be supported.</p>

<p>(The URL for the 1975 C Reference Manual may not be stable. Another copy, possibly with some subtle differences, is <a href="https://www.student.cs.uwaterloo.ca/~cs136/resources/cman.pdf" rel="noreferrer">here</a>.)</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/187690/ant" target="_blank"><span itemprop="name">AnT</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/13366083/why-does-the-arrow------operator-in-c-exist-#answer-0</div>
                                            <div itemprop="upvoteCount">330</div>
                                            <div itemprop="dateCreated">2/3/2017 4:32:54 PM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                            <div id="answer-1" class="block-question second-answer" >
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div >
                                        <p>Beyond historical (good and already reported) reasons, there's is also a little problem with operators precedence: dot operator has higher priority than star operator, so if you have struct containing pointer to struct containing pointer to struct... These two are equivalent:</p>

<pre><code>(*(*(*a).b).c).d

a-&gt;b-&gt;c-&gt;d
</code></pre>

<p>But the second is clearly more readable. Arrow operator has the highest priority (just as dot) and associates left to right. I think this is clearer than use dot operator both for pointers to struct and struct, because we know the type from the expression without have to look at the declaration, that could even be in another file.</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name"><a href="https://stackoverflow.com/users/1202636/effeffe" target="_blank">effeffe</a></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/13366083" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/13366083/why-does-the-arrow------operator-in-c-exist- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:40 GMT -->
</html>
