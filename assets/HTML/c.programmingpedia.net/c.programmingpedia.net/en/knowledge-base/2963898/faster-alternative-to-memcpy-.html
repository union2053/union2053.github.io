<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/2963898/faster-alternative-to-memcpy- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="[SOLVED] faster alternative to memcpy? | C Language Knowledge Base">
        <meta name="description" property="og:description" content="[SOLVED] faster alternative to memcpy? | C Language Knowledge Base">
        <title>[SOLVED] faster alternative to memcpy? | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="faster-alternative-to-memcpy-">faster alternative to memcpy?</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/memcpy.html">memcpy</a></span>
                        <span class="tag-item"><a href="../tag/performance.html">performance</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>I have a function that is doing memcpy, but it's taking up an enormous amount of cycles. Is there a faster alternative/approach than using memcpy to move a piece of memory?</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/148389/tony-stark" target="_blank"><span itemprop="name">Tony Stark</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">37</div>
                                    <div itemprop="dateCreated">11/3/2013 6:03:47 PM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="accepted-answer">Accepted Answer</h3>
                                    <div itemprop="text">
                                        <p><code>memcpy</code> is likely to be the fastest way you can copy bytes around in memory. If you need something faster - try figuring out a way of <em>not</em> copying things around, e.g. swap pointers only, not the data itself.</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/126769/nos" target="_blank"><span itemprop="name">nos</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/2963898/faster-alternative-to-memcpy-#answer-0</div>
                                            <div itemprop="upvoteCount">119</div>
                                            <div itemprop="dateCreated">6/3/2010 7:10:23 AM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                            <div id="answer-1" class="block-question second-answer" >
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div >
                                        <p>This is an answer for x86_64 with AVX2 instruction set present. Though something similar may apply for ARM/AArch64 with SIMD.</p>

<p>On Ryzen 1800X with single memory channel filled completely (2 slots, 16 GB DDR4 in each), the following code is 1.56 times faster than <code>memcpy()</code> on MSVC++2017 compiler. If you fill both memory channels with 2 DDR4 modules, i.e. you have all 4 DDR4 slots busy, you may get further 2 times faster memory copying. For triple-(quad-)channel memory systems, you can get further 1.5(2.0) times faster memory copying if the code is extended to analogous AVX512 code. With AVX2-only triple/quad channel systems with all slots busy are not expected to be faster because to load them fully you need to load/store more than 32 bytes at once (48 bytes for triple- and 64-bytes for quad-channel systems), while AVX2 can load/store no more than 32 bytes at once. Though multithreading on some systems can alleviate this without AVX512 or even AVX2.</p>

<p>So here is the copy code that assumes you are copying a large block of memory whose size is a multiple of 32 and the block is 32-byte aligned.</p>

<p>For non-multiple size and non-aligned blocks, prologue/epilogue code can be written reducing the width to 16 (SSE4.1), 8, 4, 2 and finally 1 byte at once for the block head and tail. Also in the middle a local array of 2-3 <code>__m256i</code> values can be used as a proxy between aligned reads from the source and aligned writes to the destination.</p>

<pre><code>#include &lt;immintrin.h&gt;
#include &lt;cstdint&gt;
/* ... */
void fastMemcpy(void *pvDest, void *pvSrc, size_t nBytes) {
  assert(nBytes % 32 == 0);
  assert((intptr_t(pvDest) &amp; 31) == 0);
  assert((intptr_t(pvSrc) &amp; 31) == 0);
  const __m256i *pSrc = reinterpret_cast&lt;const __m256i*&gt;(pvSrc);
  __m256i *pDest = reinterpret_cast&lt;__m256i*&gt;(pvDest);
  int64_t nVects = nBytes / sizeof(*pSrc);
  for (; nVects &gt; 0; nVects--, pSrc++, pDest++) {
    const __m256i loaded = _mm256_stream_load_si256(pSrc);
    _mm256_stream_si256(pDest, loaded);
  }
  _mm_sfence();
}
</code></pre>

<p>A key feature of this code is that it skips CPU cache when copying: when CPU cache is involved (i.e. AVX instructions without <code>_stream_</code> are used), the copy speed drops several times on my system.</p>

<p>My DDR4 memory is 2.6GHz CL13 . So when copying 8GB of data from one array to another I got the following speeds:</p>

<pre><code>memcpy(): 17 208 004 271 bytes/sec.
Stream copy: 26 842 874 528 bytes/sec.
</code></pre>

<p>Note that in these measurements the total size of both input and output buffers is divided by the number of seconds elapsed. Because for each byte of the array there are 2 memory accesses: one to read the byte from the input array, another to write the byte to the output array. In the other words, when copying 8GB from one array to another, you do 16GB worth of memory access operations.</p>

<p>Moderate multithreading can further improve performance about 1.44 times, so total increase over <code>memcpy()</code> reaches 2.55 times on my machine.
Here's how stream copy performance depends on the number of threads used on my machine:</p>

<pre><code>Stream copy 1 threads: 27114820909.821 bytes/sec
Stream copy 2 threads: 37093291383.193 bytes/sec
Stream copy 3 threads: 39133652655.437 bytes/sec
Stream copy 4 threads: 39087442742.603 bytes/sec
Stream copy 5 threads: 39184708231.360 bytes/sec
Stream copy 6 threads: 38294071248.022 bytes/sec
Stream copy 7 threads: 38015877356.925 bytes/sec
Stream copy 8 threads: 38049387471.070 bytes/sec
Stream copy 9 threads: 38044753158.979 bytes/sec
Stream copy 10 threads: 37261031309.915 bytes/sec
Stream copy 11 threads: 35868511432.914 bytes/sec
Stream copy 12 threads: 36124795895.452 bytes/sec
Stream copy 13 threads: 36321153287.851 bytes/sec
Stream copy 14 threads: 36211294266.431 bytes/sec
Stream copy 15 threads: 35032645421.251 bytes/sec
Stream copy 16 threads: 33590712593.876 bytes/sec
</code></pre>

<p>The code is:</p>

<pre><code>void AsyncStreamCopy(__m256i *pDest, const __m256i *pSrc, int64_t nVects) {
  for (; nVects &gt; 0; nVects--, pSrc++, pDest++) {
    const __m256i loaded = _mm256_stream_load_si256(pSrc);
    _mm256_stream_si256(pDest, loaded);
  }
}

void BenchmarkMultithreadStreamCopy(double *gpdOutput, const double *gpdInput, const int64_t cnDoubles) {
  assert((cnDoubles * sizeof(double)) % sizeof(__m256i) == 0);
  const uint32_t maxThreads = std::thread::hardware_concurrency();
  std::vector&lt;std::thread&gt; thrs;
  thrs.reserve(maxThreads + 1);

  const __m256i *pSrc = reinterpret_cast&lt;const __m256i*&gt;(gpdInput);
  __m256i *pDest = reinterpret_cast&lt;__m256i*&gt;(gpdOutput);
  const int64_t nVects = cnDoubles * sizeof(*gpdInput) / sizeof(*pSrc);

  for (uint32_t nThreads = 1; nThreads &lt;= maxThreads; nThreads++) {
    auto start = std::chrono::high_resolution_clock::now();
    lldiv_t perWorker = div((long long)nVects, (long long)nThreads);
    int64_t nextStart = 0;
    for (uint32_t i = 0; i &lt; nThreads; i++) {
      const int64_t curStart = nextStart;
      nextStart += perWorker.quot;
      if ((long long)i &lt; perWorker.rem) {
        nextStart++;
      }
      thrs.emplace_back(AsyncStreamCopy, pDest + curStart, pSrc+curStart, nextStart-curStart);
    }
    for (uint32_t i = 0; i &lt; nThreads; i++) {
      thrs[i].join();
    }
    _mm_sfence();
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    double nSec = 1e-6 * std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count();
    printf("Stream copy %d threads: %.3lf bytes/sec\n", (int)nThreads, cnDoubles * 2 * sizeof(double) / nSec);

    thrs.clear();
  }
}
</code></pre>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name"><a href="https://stackoverflow.com/users/1915854/serge-rogatch" target="_blank">Serge Rogatch</a></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/2963898" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/2963898/faster-alternative-to-memcpy- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:40 GMT -->
</html>
