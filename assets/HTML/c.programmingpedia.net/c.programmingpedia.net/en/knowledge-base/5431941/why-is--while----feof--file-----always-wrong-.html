<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/5431941/why-is--while----feof--file-----always-wrong- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:12:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="[SOLVED] Why is “while ( !feof (file) )” always wrong? | C Language Knowledge Base">
        <meta name="description" property="og:description" content="[SOLVED] Why is “while ( !feof (file) )” always wrong? | C Language Knowledge Base">
        <title>[SOLVED] Why is “while ( !feof (file) )” always wrong? | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="why-is-while-feof-file-always-wrong-">Why is “while ( !feof (file) )” always wrong?</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/feof.html">feof</a></span>
                        <span class="tag-item"><a href="../tag/file.html">file</a></span>
                        <span class="tag-item"><a href="../tag/while-loop.html">while-loop</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>I've seen people trying to read files like this in a lot of posts lately.</p>

<p><strong><em>Code</em></strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
{
    char *path = argc &gt; 1 ? argv[1] : "input.txt";

    FILE *fp = fopen(path, "r");
    if( fp == NULL ) {
        perror(path);
        return EXIT_FAILURE;
    }

    while( !feof(fp) ) {  /* THIS IS WRONG */
        /* Read and process data from file… */
    }
    if( fclose(fp) == 0 ) {
        return EXIT_SUCCESS;
    } else {
        perror(path);
        return EXIT_FAILURE;
    }
}
</code></pre>

<p>What is wrong with this loop?</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/140750/william-pursell" target="_blank"><span itemprop="name">William Pursell</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">536</div>
                                    <div itemprop="dateCreated">8/12/2019 3:20:06 PM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="accepted-answer">Accepted Answer</h3>
                                    <div itemprop="text">
                                        <p>I'd like to provide an abstract, high-level perspective.</p>

<h3 id="concurrency-and-simultaneity">Concurrency and simultaneity</h3>

<p>I/O operations interact with the environment. The environment is not part of your program, and not under your control. The environment truly exists "concurrently" with your program. As with all things concurrent, questions about the "current state" don't make sense: There is no concept of "simultaneity" across concurrent events. Many properties of state simply don't <em>exist</em> concurrently.</p>

<p>Let me make this more precise: Suppose you want to ask, "do you have more data". You could ask this of a concurrent container, or of your I/O system. But the answer is generally unactionable, and thus meaningless. So what if the container says "yes" &ndash; by the time you try reading, it may no longer have data. Similarly, if the answer is "no", by the time you try reading, data may have arrived. The conclusion is that there simply <em>is</em> no property like "I have data", since you cannot act meaningfully in response to any possible answer. (The situation is slightly better with buffered input, where you might conceivably get a "yes, I have data" that constitutes some kind of guarantee, but you would still have to be able to deal with the opposite case. And with output the situation is certainly just as bad as I described: you never know if that disk or that network buffer is full.)</p>

<p>So we conclude that it is impossible, and in fact un<em>reasonable</em>, to ask an I/O system whether it <em>will be</em> able to perform an I/O operation. The only possible way we can interact with it (just as with a concurrent container) is to <em>attempt</em> the operation and check whether it succeeded or failed. At that moment where you interact with the environment, then and only then can you know whether the interaction was actually possible, and at that point you must commit to performing the interaction. (This is a "synchronisation point", if you will.)</p>

<h3 id="eof">EOF</h3>

<p>Now we get to EOF. EOF is the <em>response</em> you get from an <em>attempted</em> I/O operation. It means that you were trying to read or write something, but when doing so you failed to read or write any data, and instead the end of the input or output was encountered. This is true for essentially all the I/O APIs, whether it be the C standard library, C++ iostreams, or other libraries. As long as the I/O operations succeed, you simply <em>cannot know</em> whether further, future operations will succeed. You <em>must</em> always first try the operation and then respond to success or failure.</p>

<h3 id="examples">Examples</h3>

<p>In each of the examples, note carefully that we <em>first</em> attempt the I/O operation and <em>then</em> consume the result if it is valid. Note further that we <em>always</em> must use the result of the I/O operation, though the result takes different shapes and forms in each example.</p>

<ul>
<li><p>C stdio, read from a file:</p>

<pre><code>for (;;) {
    size_t n = fread(buf, 1, bufsize, infile);
    consume(buf, n);
    if (n &lt; bufsize) { break; }
}
</code></pre>

<p>The result we must use is <code>n</code>, the number of elements that were read (which may be as little as zero).</p></li>
<li><p>C stdio, <code>scanf</code>:</p>

<pre><code>for (int a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c) == 3; ) {
    consume(a, b, c);
}
</code></pre>

<p>The result we must use is the return value of <code>scanf</code>, the number of elements converted.</p></li>
<li><p>C++, iostreams formatted extraction:</p>

<pre><code>for (int n; std::cin &gt;&gt; n; ) {
    consume(n);
}
</code></pre>

<p>The result we must use is <code>std::cin</code> itself, which can be evaluated in a boolean context and tells us whether the stream is still in the <code>good()</code> state.</p></li>
<li><p>C++, iostreams getline:</p>

<pre><code>for (std::string line; std::getline(std::cin, line); ) {
    consume(line);
}
</code></pre>

<p>The result we must use is again <code>std::cin</code>, just as before.</p></li>
<li><p>POSIX, <code>write(2)</code> to flush a buffer:</p>

<pre><code>char const * p = buf;
ssize_t n = bufsize;
for (ssize_t k = bufsize; (k = write(fd, p, n)) &gt; 0; p += k, n -= k) {}
if (n != 0) { /* error, failed to write complete buffer */ }
</code></pre>

<p>The result we use here is <code>k</code>, the number of bytes written. The point here is that we can only know how many bytes were written <em>after</em> the write operation.</p></li>
<li><p>POSIX <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html" rel="noreferrer"><code>getline()</code></a></p>

<pre><code>char *buffer = NULL;
size_t bufsiz = 0;
ssize_t nbytes;
while ((nbytes = getline(&amp;buffer, &amp;bufsiz, fp)) != -1)
{
    /* Use nbytes of data in buffer */
}
free(buffer);
</code></pre>

<p>The result we must use is <code>nbytes</code>, the number of bytes up to and including the newline (or EOF if the file did not end with a newline).</p>

<p>Note that the function explicitly returns <code>-1</code> (and not EOF!) when an error occurs or it reaches EOF.</p></li>
</ul>

<p>You may notice that we very rarely spell out the actual word "EOF". We usually detect the error condition in some other way that is more immediately interesting to us (e.g. failure to perform as much I/O as we had desired). In every example there is some API feature that could tell us explicitly that the EOF state has been encountered, but this is in fact not a terribly useful piece of information. It is much more of a detail than we often care about. What matters is whether the I/O succeeded, more-so than how it failed.</p>

<ul>
<li><p>A final example that actually queries the EOF state: Suppose you have a string and want to test that it represents an integer in its entirety, with no extra bits at the end except whitespace. Using C++ iostreams, it goes like this:</p>

<pre><code>std::string input = "   123   ";   // example

std::istringstream iss(input);
int value;
if (iss &gt;&gt; value &gt;&gt; std::ws &amp;&amp; iss.get() == EOF) {
    consume(value);
} else {
    // error, "input" is not parsable as an integer
}
</code></pre>

<p>We use two results here. The first is <code>iss</code>, the stream object itself, to check that the formatted extraction to <code>value</code> succeeded. But then, after also consuming whitespace, we perform another I/O/ operation, <code>iss.get()</code>, and expect it to fail as EOF, which is the case if the entire string has already been consumed by the formatted extraction.</p>

<p>In the C standard library you can achieve something similar with the <code>strto*l</code> functions by checking that the end pointer has reached the end of the input string.</p></li>
</ul>

<h3 id="the-answer">The answer</h3>

<p><code>while(!eof)</code> is wrong because it tests for something that is irrelevant and fails to test for something that you need to know. The result is that you are erroneously executing code that assumes that it is accessing data that was read successfully, when in fact this never happened.</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/596781/kerrek-sb" target="_blank"><span itemprop="name">Kerrek SB</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/5431941/why-is--while----feof--file-----always-wrong-#answer-0</div>
                                            <div itemprop="upvoteCount">431</div>
                                            <div itemprop="dateCreated">5/24/2017 3:58:34 PM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                            <div id="answer-1" class="block-question second-answer" >
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div >
                                        <p>It's wrong because (in the absence of a read error) it enters the loop one more time than the author expects.  If there is a read error, the loop never terminates.</p>

<p>Consider the following code:</p>

<pre><code>/* WARNING: demonstration of bad coding technique!! */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

FILE *Fopen(const char *path, const char *mode);

int main(int argc, char **argv)
{
    FILE *in;
    unsigned count;

    in = argc &gt; 1 ? Fopen(argv[1], "r") : stdin;
    count = 0;

    /* WARNING: this is a bug */
    while (!feof(in)) {  /* This is WRONG! */
        fgetc(in);
        count++;
    }
    printf("Number of characters read: %u\n", count);
    return EXIT_SUCCESS;
}

FILE * Fopen(const char *path, const char *mode)
{
    FILE *f = fopen(path, mode);
    if (f == NULL) {
        perror(path);
        exit(EXIT_FAILURE);
    }
    return f;
}
</code></pre>

<p>This program will consistently print one greater than the number of characters in the input stream (assuming no read errors).  Consider the case where the input stream is empty:</p>

<pre><code>$ ./a.out &lt; /dev/null
Number of characters read: 1
</code></pre>

<p>In this case, <code>feof()</code> is called before any data has been read, so it returns false.  The loop is entered, <code>fgetc()</code> is called (and returns <code>EOF</code>), and count is incremented.  Then <code>feof()</code> is called and returns true, causing the loop to abort.</p>

<p>This happens in all such cases.  <code>feof()</code> does not return true until <strong>after</strong> a read on the stream encounters the end of file.  The purpose of <code>feof()</code> is NOT to check if the next read will reach the end of file.  The purpose of <code>feof()</code> is to distinguish between a read error and having reached the end of the file.  If <code>fread()</code> returns 0, you must use <code>feof</code>/<code>ferror</code> to decide whether an error was encountered or if all of the data was consumed.  Similarly if <code>fgetc</code> returns <code>EOF</code>.  <code>feof()</code> is only useful <strong>after</strong> fread has returned zero or <code>fgetc</code> has returned <code>EOF</code>.  Before that happens, <code>feof()</code> will always return 0.</p>

<p>It is always necessary to check the return value of a read (either an <code>fread()</code>, or an <code>fscanf()</code>, or an <code>fgetc()</code>) before calling <code>feof()</code>.</p>

<p>Even worse, consider the case where a read error occurs.  In that case, <code>fgetc()</code> returns <code>EOF</code>, <code>feof()</code> returns false, and the loop never terminates.  In all cases where <code>while(!feof(p))</code> is used, there must be at least a check inside the loop for <code>ferror()</code>, or at the very least the while condition should be replaced with <code>while(!feof(p) &amp;&amp; !ferror(p))</code> or there is a very real possibility of an infinite loop, probably spewing all sorts of garbage as invalid data is being processed.</p>

<p>So, in summary, although I cannot state with certainty that there is never a situation in which it may be semantically correct to write "<code>while(!feof(f))</code>" (although there <strong>must</strong> be another check inside the loop with a break to avoid a infinite loop on a read error), it is the case that it is almost certainly always wrong.  And even if a case ever arose where it would be correct, it is so idiomatically wrong that it would not be the right way to write the code.  Anyone seeing that code should immediately hesitate and say, "that's a bug".  And possibly slap the author (unless the author is your boss in which case discretion is advised.)</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name"><a href="https://stackoverflow.com/users/140750/william-pursell" target="_blank">William Pursell</a></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/5431941" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/5431941/why-is--while----feof--file-----always-wrong- by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:12:11 GMT -->
</html>
