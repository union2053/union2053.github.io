<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/1591361/understanding-typedefs-for-function-pointers-in-c by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="Understanding typedefs for function pointers in C | C Language Knowledge Base">
        <meta name="description" property="og:description" content="Understanding typedefs for function pointers in C | C Language Knowledge Base">
        <title>Understanding typedefs for function pointers in C | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="understanding-typedefs-for-function-pointers-in-c">Understanding typedefs for function pointers in C</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/function-pointers.html">function-pointers</a></span>
                        <span class="tag-item"><a href="../tag/typedef.html">typedef</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>I have always been a bit stumped when I read other peoples' code which had typedefs for pointers to functions with arguments. I recall that it took me a while to get around to such a definition while trying to understand a numerical algorithm written in C a while ago. So, could you share your tips and thoughts on how to write good typedefs for pointers to functions (Do's and Do not's), as to why are they useful and how to understand others' work? Thanks!</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/0/user192712" target="_blank"><span itemprop="name">user192712</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">219</div>
                                    <div itemprop="dateCreated">4/5/2016 9:08:16 AM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question second-answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div itemprop="text">
                                        <p>Consider the <code>signal()</code> function from the C standard:</p>

<pre><code>extern void (*signal(int, void(*)(int)))(int);
</code></pre>

<p>Perfectly obscurely obvious - it's a function that takes two arguments, an integer and a pointer to a function that takes an integer as an argument and returns nothing, and it (<code>signal()</code>) returns a pointer to a function that takes an integer as an argument and returns nothing.</p>

<p>If you write:</p>

<pre><code>typedef void (*SignalHandler)(int signum);
</code></pre>

<p>then you can instead declare <code>signal()</code> as:</p>

<pre><code>extern  SignalHandler signal(int signum, SignalHandler handler);
</code></pre>

<p>This means the same thing, but is usually regarded as somewhat easier to read.  It is clearer that the function takes an <code>int</code> and a <code>SignalHandler</code> and returns a <code>SignalHandler</code>.</p>

<p>It takes a bit of getting used to, though.  The one thing you can't do, though is write a signal handler function using the <code>SignalHandler</code> <code>typedef</code> in the function definition.</p>

<p>I'm still of the old-school that prefers to invoke a function pointer as:</p>

<pre><code>(*functionpointer)(arg1, arg2, ...);
</code></pre>

<p>Modern syntax uses just:</p>

<pre><code>functionpointer(arg1, arg2, ...);
</code></pre>

<p>I can see why that works - I just prefer to know that I need to look for where the variable is initialized rather than for a function called <code>functionpointer</code>.</p>

<hr>

<p>Sam commented:</p>

<blockquote>
  <p>I have seen this explanation before. And then, as is the case now, I think what I didn't get was the connection between the two statements:</p>

<pre><code>    extern void (*signal(int, void()(int)))(int);  /*and*/

    typedef void (*SignalHandler)(int signum);
    extern SignalHandler signal(int signum, SignalHandler handler);
</code></pre>
  
  <p>Or, what I want to ask is, what is the underlying concept that one can use to come up with the second version you have? What is the fundamental that connects "SignalHandler" and the first typedef? I think what needs to be explained here is what is typedef is actually doing here.</p>
</blockquote>

<p>Let's try again.  The first of these is lifted straight from the C standard - I retyped it, and checked that I had the parentheses right (not until I corrected it - it is a tough cookie to remember).</p>

<p>First of all, remember that <code>typedef</code> introduces an alias for a type.  So, the alias is <code>SignalHandler</code>, and its type is:</p>

<blockquote>
  <p>a pointer to a function that takes an integer as an argument and returns nothing.</p>
</blockquote>

<p>The 'returns nothing' part is spelled <code>void</code>; the argument that is an integer is (I trust) self-explanatory.  The following notation is simply (or not) how C spells pointer to function taking arguments as specified and returning the given type:</p>

<pre><code>type (*function)(argtypes);
</code></pre>

<p>After creating the signal handler type, I can use it to declare variables and so on.  For example:</p>

<pre><code>static void alarm_catcher(int signum)
{
    fprintf(stderr, "%s() called (%d)\n", __func__, signum);
}

static void signal_catcher(int signum)
{
    fprintf(stderr, "%s() called (%d) - exiting\n", __func__, signum);
    exit(1);
}

static struct Handlers
{
    int              signum;
    SignalHandler    handler;
} handler[] =
{
    { SIGALRM,   alarm_catcher  },
    { SIGINT,    signal_catcher },
    { SIGQUIT,   signal_catcher },
};

int main(void)
{
    size_t num_handlers = sizeof(handler) / sizeof(handler[0]);
    size_t i;

    for (i = 0; i &lt; num_handlers; i++)
    {
        SignalHandler old_handler = signal(handler[i].signum, SIG_IGN);
        if (old_handler != SIG_IGN)
            old_handler = signal(handler[i].signum, handler[i].handler);
        assert(old_handler == SIG_IGN);
    }

    ...continue with ordinary processing...

    return(EXIT_SUCCESS);
}
</code></pre>

<p><sup>Please note <a href="https://stackoverflow.com/questions/16891019">How to avoid using <code>printf()</code> in a signal handler?</a></sup></p>

<p>So, what have we done here - apart from omit 4 standard headers that would be needed to make the code compile cleanly?</p>

<p>The first two functions are functions that take a single integer and return nothing.  One of them actually doesn't return at all thanks to the <code>exit(1);</code> but the other does return after printing a message.  Be aware that the C standard does not permit you to do very much inside a signal handler; <a href="http://www.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04" rel="noreferrer">POSIX</a> is a bit more generous in what is allowed, but officially does not sanction calling <code>fprintf()</code>.  I also print out the signal number that was received.  In the <code>alarm_handler()</code> function, the value will always be <code>SIGALRM</code> as that is the only signal that it is a handler for, but <code>signal_handler()</code> might get <code>SIGINT</code> or <code>SIGQUIT</code> as the signal number because the same function is used for both.</p>

<p>Then I create an array of structures, where each element identifies a signal number and the handler to be installed for that signal.  I've chosen to worry about 3 signals; I'd often worry about <code>SIGHUP</code>, <code>SIGPIPE</code> and <code>SIGTERM</code> too and about whether they are defined (<code>#ifdef</code> conditional compilation), but that just complicates things.  I'd also probably use POSIX <code>sigaction()</code> instead of <code>signal()</code>, but that is another issue; let's stick with what we started with.</p>

<p>The <code>main()</code> function iterates over the list of handlers to be installed.  For each handler, it first calls <code>signal()</code> to find out whether the process is currently ignoring the signal, and while doing so, installs <code>SIG_IGN</code> as the handler, which ensures that the signal stays ignored.  If the signal was not previously being ignored, it then calls <code>signal()</code> again, this time to install the preferred signal handler.  (The other value is presumably<code>SIG_DFL</code>, the default signal handler for the signal.)  Because the first call to 'signal()' set the handler to <code>SIG_IGN</code> and <code>signal()</code> returns the previous error handler, the value of <code>old</code> after the <code>if</code> statement must be <code>SIG_IGN</code> - hence the assertion.  (Well, it could be <code>SIG_ERR</code> if something went dramatically wrong - but then I'd learn about that from the assert firing.)</p>

<p>The program then does its stuff and exits normally.</p>

<p>Note that the name of a function can be regarded as a pointer to a function of the appropriate type.  When you do not apply the function-call parentheses - as in the initializers, for example - the function name becomes a function pointer.  This is also why it is reasonable to invoke functions via the <code>pointertofunction(arg1, arg2)</code> notation; when you see <code>alarm_handler(1)</code>, you can consider that <code>alarm_handler</code> is a pointer to the function and therefore <code>alarm_handler(1)</code> is an invocation of a function via a function pointer.</p>

<p>So, thus far, I've shown that a <code>SignalHandler</code> variable is relatively straight-forward to use, as long as you have some of the right type of value to assign to it - which is what the two signal handler functions provide.</p>

<p>Now we get back to the question - how do the two declarations for <code>signal()</code> relate to each other.</p>

<p>Let's review the second declaration:</p>

<pre><code> extern SignalHandler signal(int signum, SignalHandler handler);
</code></pre>

<p>If we changed the function name and the type like this:</p>

<pre><code> extern double function(int num1, double num2);
</code></pre>

<p>you would have no problem interpreting this as a function that takes an <code>int</code> and a <code>double</code> as arguments and returns a <code>double</code> value (would you? maybe you'd better not 'fess up if that is problematic - but maybe you should be cautious about asking questions as hard as this one if it is a problem).</p>

<p>Now, instead of being a <code>double</code>, the <code>signal()</code> function takes a <code>SignalHandler</code> as its second argument, and it returns one as its result.</p>

<p>The mechanics by which that can also be treated as:</p>

<pre><code>extern void (*signal(int signum, void(*handler)(int signum)))(int signum);
</code></pre>

<p>are tricky to explain - so I'll probably screw it up.  This time I've given the parameters names - though the names aren't critical.</p>

<p>In general, in C, the declaration mechanism is such that if you write:</p>

<pre><code>type var;
</code></pre>

<p>then when you write <code>var</code> it represents a value of the given <code>type</code>.  For example:</p>

<pre><code>int     i;            // i is an int
int    *ip;           // *ip is an int, so ip is a pointer to an integer
int     abs(int val); // abs(-1) is an int, so abs is a (pointer to a)
                      // function returning an int and taking an int argument
</code></pre>

<p>In the standard, <code>typedef</code> is treated as a storage class in the grammar, rather like <code>static</code> and <code>extern</code> are storage classes.</p>

<pre><code>typedef void (*SignalHandler)(int signum);
</code></pre>

<p>means that when you see a variable of type <code>SignalHandler</code> (say alarm_handler) invoked as:</p>

<pre><code>(*alarm_handler)(-1);
</code></pre>

<p>the result has <code>type void</code> - there is no result.  And <code>(*alarm_handler)(-1);</code> is an invocation of <code>alarm_handler()</code> with argument <code>-1</code>.</p>

<p>So, if we declared:</p>

<pre><code>extern SignalHandler alt_signal(void);
</code></pre>

<p>it means that:</p>

<pre><code>(*alt_signal)();
</code></pre>

<p>represents a void value.  And therefore:</p>

<pre><code>extern void (*alt_signal(void))(int signum);
</code></pre>

<p>is equivalent.  Now, <code>signal()</code> is more complex because it not only returns a <code>SignalHandler</code>, it also accepts both an int and a <code>SignalHandler</code> as arguments:</p>

<pre><code>extern void (*signal(int signum, SignalHandler handler))(int signum);

extern void (*signal(int signum, void (*handler)(int signum)))(int signum);
</code></pre>

<p>If that still confuses you, I'm not sure how to help - it is still at some levels mysterious to me, but I've grown used to how it works and can therefore tell you that if you stick with it for another 25 years or so, it will become second nature to you (and maybe even a bit quicker if you are clever).</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/15168/jonathan-leffler" target="_blank"><span itemprop="name">Jonathan Leffler</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/1591361/understanding-typedefs-for-function-pointers-in-c#answer-0</div>
                                            <div itemprop="upvoteCount">278</div>
                                            <div itemprop="dateCreated">5/23/2017 12:10:26 PM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/1591361" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/1591361/understanding-typedefs-for-function-pointers-in-c by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:14 GMT -->
</html>
