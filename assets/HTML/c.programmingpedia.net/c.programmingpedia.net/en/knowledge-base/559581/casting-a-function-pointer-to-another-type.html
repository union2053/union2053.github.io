<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/559581/casting-a-function-pointer-to-another-type by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:16:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="[SOLVED] Casting a function pointer to another type | C Language Knowledge Base">
        <meta name="description" property="og:description" content="[SOLVED] Casting a function pointer to another type | C Language Knowledge Base">
        <title>[SOLVED] Casting a function pointer to another type | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="casting-a-function-pointer-to-another-type">Casting a function pointer to another type</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/function-pointers.html">function-pointers</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>Let's say I have a function that accepts a <code>void (*)(void*)</code> function pointer for use as a callback:</p>

<pre><code>void do_stuff(void (*callback_fp)(void*), void* callback_arg);
</code></pre>

<p>Now, if I have a function like this:</p>

<pre><code>void my_callback_function(struct my_struct* arg);
</code></pre>

<p>Can I do this safely?</p>

<pre><code>do_stuff((void (*)(void*)) &amp;my_callback_function, NULL);
</code></pre>

<p>I've looked at <a href="https://stackoverflow.com/questions/188839/function-pointer-cast-to-different-signature">this question</a> and I've looked at some C standards which say you can cast to 'compatible function pointers', but I cannot find a definition of what 'compatible function pointer' means.</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/49658/mike-weller" target="_blank"><span itemprop="name">Mike Weller</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">77</div>
                                    <div itemprop="dateCreated">5/23/2017 11:54:56 AM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="accepted-answer">Accepted Answer</h3>
                                    <div itemprop="text">
                                        <p>As far as the C standard is concerned, if you cast a function pointer to a function pointer of a different type and then call that, it is <em>undefined behavior</em>.  See Annex J.2 (informative):</p>

<blockquote>
  <p>The behavior is undefined in the following circumstances:</p>
  
  <ul>
  <li>A pointer is used to call a function whose type is not compatible with the pointed-to 
  type (6.3.2.3). </li>
  </ul>
</blockquote>

<p>Section 6.3.2.3, paragraph 8 reads:</p>

<blockquote>
  <p>A pointer to a function of one type may be converted to a pointer to a function of another 
  type and back again; the result shall compare equal to the original pointer. If a converted 
  pointer is used to call a function whose type is not compatible with the pointed-to type, 
  the behavior is undefined.</p>
</blockquote>

<p>So in other words, you can cast a function pointer to a different function pointer type, cast it back again, and call it, and things will work.</p>

<p>The definition of <em>compatible</em> is somewhat complicated.  It can be found in section 6.7.5.3, paragraph 15:</p>

<blockquote>
  <p>For two function types to be compatible, both shall specify compatible return types<sup>127</sup>.</p>
  
  <p>Moreover, the parameter type lists, if both are present, shall agree in the number of 
  parameters and in use of the ellipsis terminator; corresponding parameters shall have 
  compatible types. If one type has a parameter type list and the other type is specified by a 
  function declarator that is not part of a function definition and that contains an empty 
  identifier list, the parameter list shall not have an ellipsis terminator and the type of each 
  parameter shall be compatible with the type that results from the application of the 
  default argument promotions. If one type has a parameter type list and the other type is 
  specified by a function definition that contains a (possibly empty) identifier list, both shall 
  agree in the number of parameters, and the type of each prototype parameter shall be 
  compatible with the type that results from the application of the default argument 
  promotions to the type of the corresponding identifier. (In the determination of type 
  compatibility and of a composite type, each parameter declared with function or array 
  type is taken as having the adjusted type and each parameter declared with qualified type 
  is taken as having the unqualified version of its declared type.) </p>
  
  <p>127) If both function types are ‘‘old style’’, parameter types are not compared.</p>
</blockquote>

<p>The rules for determining whether two types are compatible are described in section 6.2.7, and I won't quote them here since they're rather lengthy, but you can read them on the <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf" rel="nofollow noreferrer">draft of the C99 standard (PDF)</a>.</p>

<p>The relevant rule here is in section 6.7.5.1, paragraph 2:</p>

<blockquote>
  <p>For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.</p>
</blockquote>

<p>Hence, since a <code>void*</code> <a href="https://stackoverflow.com/questions/11647220/are-void-pointer-and-pointer-to-some-structure-layout-compatible">is not compatible</a> with a <code>struct my_struct*</code>, a function pointer of type <code>void (*)(void*)</code> is not compatible with a function pointer of type <code>void (*)(struct my_struct*)</code>, so this casting of function pointers is technically undefined behavior.</p>

<p>In practice, though, you can safely get away with casting function pointers in some cases.  In the x86 calling convention, arguments are pushed on the stack, and all pointers are the same size (4 bytes in x86 or 8 bytes in x86_64).  Calling a function pointer boils down to pushing the arguments on the stack and doing an indirect jump to the function pointer target, and there's obviously no notion of types at the machine code level.</p>

<p>Things you definitely <strong>can't</strong> do:</p>

<ul>
<li>Cast between function pointers of different calling conventions.  You will mess up the stack and at best, crash, at worst, succeed silently with a huge gaping security hole.  In Windows programming, you often pass function pointers around.  Win32 expects all callback functions to use the <code>stdcall</code> calling convention (which the macros <code>CALLBACK</code>, <code>PASCAL</code>, and <code>WINAPI</code> all expand to).  If you pass a function pointer that uses the standard C calling convention (<code>cdecl</code>), badness will result.</li>
<li>In C++, cast between class member function pointers and regular function pointers.  This often trips up C++ newbies.  Class member functions have a hidden <code>this</code> parameter, and if you cast a member function to a regular function, there's no <code>this</code> object to use, and again, much badness will result.</li>
</ul>

<p>Another bad idea that might sometimes work but is also undefined behavior:</p>

<ul>
<li>Casting between function pointers and regular pointers (e.g. casting a <code>void (*)(void)</code> to a <code>void*</code>).  Function pointers aren't necessarily the same size as regular pointers, since on some architectures they might contain extra contextual information.  This will probably work ok on x86, but remember that it's undefined behavior.</li>
</ul>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/9530/adam-rosenfield" target="_blank"><span itemprop="name">Adam Rosenfield</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/559581/casting-a-function-pointer-to-another-type#answer-0</div>
                                            <div itemprop="upvoteCount">115</div>
                                            <div itemprop="dateCreated">5/3/2019 10:33:47 AM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                            <div id="answer-1" class="block-question second-answer" >
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div >
                                        <p>I asked about this exact same issue regarding some code in GLib recently.  (GLib is a core library for the GNOME project and written in C.)  I was told the entire slots'n'signals framework depends upon it.</p>

<p>Throughout the code, there are numerous instances of casting from type (1) to (2):</p>

<ol>
<li><code>typedef int (*CompareFunc)     (const void *a, 
                                 const void *b)</code></li>
<li><code>typedef int (*CompareDataFunc) (const void *b, 
                                 const void *b, 
                                 void *user_data)</code></li>
</ol>

<p>It is common to chain-thru with calls like this:</p>

<pre><code>int stuff_equal (GStuff      *a,
                 GStuff      *b,
                 CompareFunc  compare_func)
{
    return stuff_equal_with_data(a, b, (CompareDataFunc) compare_func, NULL);
}

int stuff_equal_with_data (GStuff          *a,
                           GStuff          *b,
                           CompareDataFunc  compare_func,
                           void            *user_data)
{
    int result;
    /* do some work here */
    result = compare_func (data1, data2, user_data);
    return result;
}
</code></pre>

<p>See for yourself here in <code>g_array_sort()</code>: <a href="http://git.gnome.org/browse/glib/tree/glib/garray.c" rel="noreferrer">http://git.gnome.org/browse/glib/tree/glib/garray.c</a></p>

<p>The answers above are detailed and likely correct -- <strong>if</strong> you sit on the standards committee.  Adam and Johannes deserve credit for their well-researched responses.  However, out in the wild, you will find this code works just fine.  Controversial?  Yes.  Consider this: GLib compiles/works/tests on a large number of platforms (Linux/Solaris/Windows/OS X) with a wide variety of compilers/linkers/kernel loaders (GCC/CLang/MSVC).  Standards be damned, I guess.</p>

<p>I spent some time thinking about these answers.  Here is my conclusion:</p>

<ol>
<li>If you are writing a callback library, this might be OK.  Caveat emptor -- use at your own risk.</li>
<li>Else, don't do it.</li>
</ol>

<p>Thinking deeper after writing this response, I would not be surprised if the code for C compilers uses this same trick.  And since (most/all?) modern C compilers are bootstrapped, this would imply the trick is safe.</p>

<p>A more important question to research: Can someone find a platform/compiler/linker/loader where this trick does <strong>not</strong> work?  Major brownie points for that one.  I bet there are some embedded processors/systems that don't like it.  However, for desktop computing (and probably mobile/tablet), this trick probably still works.</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name"><a href="https://stackoverflow.com/users/257299/kevinarpe" target="_blank">kevinarpe</a></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/559581" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/559581/casting-a-function-pointer-to-another-type by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:16:32 GMT -->
</html>
