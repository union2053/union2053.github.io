<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/1192487/swap-bits-in-a-number-in-c by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 09:45:54 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="[SOLVED] Swap bits in a number in C | C Language Knowledge Base">
        <meta name="description" property="og:description" content="[SOLVED] Swap bits in a number in C | C Language Knowledge Base">
        <title>[SOLVED] Swap bits in a number in C | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="swap-bits-in-a-number-in-c">Swap bits in a number in C</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/bit-manipulation.html">bit-manipulation</a></span>
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>In a C interview, I was asked to swap the first 4-bits of a number with the last 4 bit. (eg. 1011 1110 should be 1110 1011.)</p>

<p>Does anyone have a solution for this?</p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/0/user146206" target="_blank"><span itemprop="name">user146206</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">10</div>
                                    <div itemprop="dateCreated">7/28/2009 7:55:04 AM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="accepted-answer">Accepted Answer</h3>
                                    <div itemprop="text">
                                        <p>See also an earlier version of <a href="https://stackoverflow.com/a/31488147/224132">this answer on another rotate question</a> with some more details about what asm gcc/clang produce for x86.</p>

<p>The most compiler-friendly way to express a rotate in C and C++ that avoids any Undefined Behaviour seems to be <a href="http://blog.regehr.org/archives/1063" rel="noreferrer">John Regehr's implementation</a>.  I've adapted it to rotate by the width of the type (using fixed-width types like <code>uint32_t</code>).</p>

<pre><code>#include &lt;stdint.h&gt;   // for uint32_t
#include &lt;limits.h&gt;   // for CHAR_BIT
// #define NDEBUG
#include &lt;assert.h&gt;

static inline uint32_t rotl32 (uint32_t n, unsigned int c)
{
  const unsigned int mask = (CHAR_BIT*sizeof(n) - 1);  // assumes width is a power of 2.

  // assert ( (c&lt;=mask) &amp;&amp;"rotate by type width or more");
  c &amp;= mask;
  return (n&lt;&lt;c) | (n&gt;&gt;( (-c)&amp;mask ));
}

static inline uint32_t rotr32 (uint32_t n, unsigned int c)
{
  const unsigned int mask = (CHAR_BIT*sizeof(n) - 1);

  // assert ( (c&lt;=mask) &amp;&amp;"rotate by type width or more");
  c &amp;= mask;
  return (n&gt;&gt;c) | (n&lt;&lt;( (-c)&amp;mask ));
}
</code></pre>

<p>Works for any unsigned integer type, not just <code>uint32_t</code>, so you could make versions for other sizes.</p>

<p><strong>See <a href="https://gist.github.com/pabigot/7550454" rel="noreferrer">also a C++11 template version</a> with lots of safety checks (including a <code>static_assert</code> that the type width is a power of 2)</strong>, which isn't the case on some 24-bit DSPs or 36-bit mainframes, for example.</p>

<p>I'd recommend only using the template as a back-end for wrappers with names that include the rotate width explicitly.  <strong>Integer-promotion rules mean that <code>rotl_template(u16 &amp; 0x11UL, 7)</code> would do a 32 or 64-bit rotate, not 16</strong> (depending on the width of <code>unsigned long</code>).  Even <code>uint16_t &amp; uint16_t</code> is promoted to <code>signed int</code> by C++'s integer-promotion rules, except on platforms where <code>int</code> is no wider than <code>uint16_t</code>.</p>

<hr>

<p><strong>On x86</strong>, this version <a href="https://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSBnVAV2OUxAHIBSAJgGY8AO2QAbZlgDU3fgGEGBfEIIA6BDOzcADAEE%2B/LADNhmSQDkAItgBCAVQDi2vQOFiJpmbICGDBpmKq6vyauvqu4lKeongAtoQMahpOTgD0aekZkqgADgSxXqKSBACe2aaGJJLEqAReBJgAtGjMypJexKCpAFSSzMIE/LwA%2BgSSQm3ZZe0MWbn5oiqSkngqmItCfABsMhYxPgDWMtaSaDHZeKKYM0SSAF7%2BqMtCDM9Okj0VxJIxJKbIPlcsoYqjUAO54dAEBAjIoILzjcFQtpCYpZKH%2BIqlcqVISLLopZK6NK9fqbAAsMPG/2YfhmwGQyCKjy8yAIzAKolRmDio3hkh0lieL1IkgARsxRmJ4cBJOhUFchGBOKpUikScpyZTJKCEBdTNUCODIdDRngZoNRScvDTAXgGcj0CdRNKmWMar0/JIAEoAeQAMoSdCken1lAAOLUFUFeYozam05GSTAADwIxC8/MFhmqMUk9OQIuImGA7XQl18QJBhohUNIbx68Md8cBUqEMpuQndNra3v9QvG%2BMDGWHkgACtVRZcYjNEQhZXhDIZ/JhWgajVCRt0nS7G8t7XLFcq8yv/HVTBnfX7%2B9qECuq%2Bu52bJGGsl9aJs67p3lVi6XyzNUGBQ9rixRY833eUEnrSRkzDTZJAYXVDAIFIDTPIU02YVk8FQZ5tUIOcX13d8xUIWZTyEdAGgYPB7mghQLkKXDOW%2BA5YT%2BFhWlnSQtGTWgADFJAgfhaAAShFTtRloABWV9JAAdhUesCVCXQSjKIx1QGYZRjXGsTSOQM9ONGEDUKCBjI3UZkxFFoaOAIRMEdfoxlE5J5OsN4TlwhRZUwMR1MwCAhFE1iGH2aR%2BAsITZAACR0L0hmsABJAAVLoaPuQCIGTUKGkkMTDK/SRiSoGlRm7Oy8AcpynlGT52O8lpRj2cLeiEf9JGKFglSLJNkzKYhYhXPI23wpFTnOS4vlFTA4QANxw1hAyWHw/ACISNjkHZWoirYtmkXheDQ%2BoxVRH4%2BqhPlAvw40%2BF4Nz%2BE84rxn2qKwsOJ6lmJLx5tQCF2s02aFqWr5uMsGwHCU4qizZYhxhyzxPBC6R5NkITkySYIICEhoQq2XbJFEx7nr0eSLEDMJgS0JxLJNKsvgssF9JhGz2vsxznNafHQg8ry0GeUYsACrFgtCwmdhi%2BLEpS9LMswbLcskfLCqery1v8UZgqRqKJd4bZ9cO46anQ0Vzt%2BWFrqxW6oXukmvNe/XJd2oqdCWWHWARzHgg0FHuDRjGddkHGIDxtz9cJ4nXf9inQgEFd8EMIzmZM3SaiGAWFCZ6tU5g0L/dJ93MDh8YzJykV5Pt3nY70OPBGBMAwCMEx0AgIYM%2BdNt2/zp3DYgZvObboZYM2IZNSGfO0f99GB6coe8H4ODu7c1TnHrzT24AWQAZVkIYADVsC9ZIXBECIPDkfohtxIIQjXzBRD8E/BDP9xItkEer%2BERJgm%2BtUzHdGVXynhYhxGUNfH%2B2BJANUmnqYgAF0RfCuuMO0yBn4JwXMnHOVkqyiGHkvL%2Bzw7TZwfKzWyRCaqOj9nzYqaQPbw0kO3cUFxRpDDwF4QYQxqjEF1OXBSJM/4FU2A0UUZETqYBFPYMwthJCyC8vQ8YXCaiiD4fjL6JU1T5hFKgkU055rIDAslZQD8Giz3QGBWQncZRygVEqUYC1TBQjNDIfiXk6HF09owpRohW5szUccDR4ECx7gMW4tU/xDz1WEI6eExQnFjRgVYlx7ka76AwUnVexIADqeB9h4A0uwpUMwFwQFEk0W8yAIpeHQF4XItUGrtFEWmdoqJxE23UESNUOS8kFIzDaR03BNhaCqpQuqkh5oFGYJgQZWgRS7gzMYZMtUHyVkGCKHUdo5zRgAqKRaLAGAsUkpIbIJBaiTmmboEZnMxngh6U5dhSiCAqLpjCCZ4gJFjMQguAgk9C5LG8oLG5%2BlIrRTiglJKaUMq0QVoYCAbyplVzdv8zOppWgS3eislWrt/nLGBFAL5yFDrbHertfOUVJZaBXkinFCjxmTOmWrYqRcS5CXhRfORcgEJIR%2BajdGcL6WRU0L/CAmKuXfKjoysmqSiRdCcFc2qLlbn5PuV4R5xASEs1GGy7RrQCU8oLl5JYKKgXGhBbI6WEK5bQuymyxFOLjUuXRdFUVtBsX/IXEJCAeqiXOwOGSim71KWGv%2BbStlbrmWeP5e8wVGgxXIUnnytl79PBCVFXqiVpMY5OHxJwcSoguDSU4KQIQXAtBFtQFwORvBPLVoQiwNgHgBC0CLQQUtubxL7BAPwTYKgACc8l3y9vJPJAd5J%2BBklIPmzgZIi0ls4GW0gFbOBFoYCAWZrb525tIHAWASBYHTXIJQfd/gQDAE2PwUgxhRD1HgZQUUbbSCnBiCNH0HVigPvwEWbC80rgPv6A/Nt4kch5B8lwBoPp%2BDKwUOgHYaDq18GsLQWgysskchXfW9gdA80FtnQ%2BpdI8GjkiCZIHtkGIC4EIJUfQ9BZGoDOHAw6IlRItsAx2rtWgVD8H4FofWZJF69v1tJaS8lJ1cBncWvDXAV1rtIBust4kd1QBgIgFAdGpr%2BEPRAY9xAUBWLJFoWZV6b2rogPezdj66PPuUK%2BzkH68BfryD%2B1d5n/1Tvk4uuYoHODgcg9RRQsGEMIaQyhtDjAMMcDEqJzghaJPmfw3BQjZJtxjTJCoDjWghIUaIF8ajIpZBqYY/oB6LHN3E1ILeapJ7SmkE7YMFQmxe1hi0PwXttAuPCa0EhqL4mYggE2LQFQvA2tkhG41/tWgwxtdiwupd0n12Ae3cpiAe6CsHooFp1bJ6xC0F7WPCdRn/AmbMwup9L6312Yc3gJzf7jFua3cBnCzwwM%2BmTOh1gmHItTpi3OmbXACNEdkFeHbkheCdfkt6VKWTMv4Gy4xmj%2BX6PTUY/wZjsnWPlcwJVnT1Wp09a7WGFQ8k4JCekp1njrWwwiZ%2B%2BWqTjAZNyfbTVrtvB6uNea619r8lOv0CnfwXDcXacM7K1O3g/PfvLrR6V8SP74GPZAGSIAA" rel="noreferrer">inlines to a single <code>rol r32, cl</code></a> (or <code>rol r32, imm8</code>) with compilers that grok it, because the compiler knows that <a href="http://felixcloutier.com/x86/RCL:RCR:ROL:ROR.html" rel="noreferrer">x86 rotate and shift instructions</a> mask the shift-count the same way the C source does.</p>

<p>Compiler support for this UB-avoiding idiom on x86, for <code>uint32_t x</code> and <code>unsigned int n</code> for variable-count shifts:</p>

<ul>
<li>clang: recognized for variable-count rotates since clang3.5, multiple shifts+or insns before that.</li>
<li>gcc: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57157" rel="noreferrer">recognized  for variable-count rotates since gcc4.9</a>, multiple shifts+or insns before that.  gcc5 and later optimize away the branch and mask in the wikipedia version, too, using just a <code>ror</code> or <code>rol</code> instruction for variable counts.</li>
<li>icc: <a href="https://software.intel.com/en-us/forums/intel-c-compilers-in-inde/topic/580884" rel="noreferrer">supported for variable-count rotates since ICC13 or earlier</a>.  Constant-count rotates use <code>shld edi,edi,7</code> which is slower and takes more bytes than <code>rol edi,7</code> on some CPUs (especially AMD, but also some Intel), when BMI2 isn't available for <code>rorx eax,edi,25</code> to save a MOV.</li>
<li>MSVC: x86-64 CL19: Only recognized for constant-count rotates.  (The wikipedia idiom is recognized, but the branch and AND aren't optimized away).  Use the <code>_rotl</code> / <code>_rotr</code> intrinsics from <code>&lt;intrin.h&gt;</code> on x86 (including x86-64).</li>
</ul>

<p><strong>gcc for ARM uses an <code>and r1, r1, #31</code> for variable-count rotates, but still does the actual rotate with a single instruction</strong>: <code>ror r0, r0, r1</code>.  So gcc doesn't realize that rotate-counts are inherently modular.  As the ARM docs say, <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABFFEJF.html" rel="noreferrer">"ROR with shift length, <code>n</code>, more than 32 is the same as ROR with shift length <code>n-32</code>"</a>.  I think gcc gets confused here because left/right shifts on ARM saturate the count, so a shift by 32 or more will clear the register.  (Unlike x86, where shifts mask the count the same as rotates).  It probably decides it needs an AND instruction before recognizing the rotate idiom, because of how non-circular shifts work on that target.</p>

<p>Current x86 compilers still use an extra instruction to mask a variable count for 8 and 16-bit rotates, probably for the same reason they don't avoid the AND on ARM.  This is a missed optimization, because performance doesn't depend on the rotate count on any x86-64 CPU.  (Masking of counts was introduced with 286 for performance reasons because it handled shifts iteratively, not with constant-latency like modern CPUs.)</p>

<p>BTW, prefer rotate-right for variable-count rotates, to avoid making the compiler do <code>32-n</code> to implement a left rotate on architectures like ARM and MIPS that only provide a rotate-right.  (This optimizes away with compile-time-constant counts.)</p>

<p>Fun fact: ARM doesn't really have dedicated shift/rotate instructions, it's just MOV with the <a href="https://cseweb.ucsd.edu/classes/wi14/cse30-c/lectures/PI_WI_14_CSE30_lecture_8_post.pdf" rel="noreferrer">source operand going through the barrel-shifter in ROR mode</a>: <code>mov r0, r0, ror r1</code>.  So a rotate can fold into a register-source operand for an EOR instruction or something.</p>

<hr>

<p><strong>Make sure you use unsigned types for <code>n</code> and the return value, or else it won't be a rotate</strong>.  (gcc for x86 targets does arithmetic right shifts, shifting in copies of the sign-bit rather than zeroes, leading to a problem when you <code>OR</code> the two shifted values together.  Right-shifts of negative signed integers is implementation-defined behaviour in C.)</p>

<p>Also, <strong>make sure the shift count is an unsigned type</strong>, because <code>(-n)&amp;31</code> with a signed type could be one's complement or sign/magnitude, and not the same as the modular 2^n you get with unsigned or two's complement.  (See comments on Regehr's blog post).  <code>unsigned int</code> does well on every compiler I've looked at, for every width of <code>x</code>.  Some other types actually defeat the idiom-recognition for some compilers, so don't just use the same type as <code>x</code>.</p>

<hr>

<p><strong>Some compilers provide intrinsics for rotates</strong>, which is far better than inline-asm if the portable version doesn't generate good code on the compiler you're targeting.  There aren't cross-platform intrinsics for any compilers that I know of.  These are some of the x86 options:</p>

<ul>
<li>Intel documents that <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,Other&amp;expand=3236,3233,5453,5453,5534,1649,5169,4433,4431&amp;text=rotl" rel="noreferrer"><code>&lt;immintrin.h&gt;</code> provides <code>_rotl</code> and <code>_rotl64</code> intrinsics</a>, and same for right shift.  MSVC requires <code>&lt;intrin.h&gt;</code>, while gcc require <code>&lt;x86intrin.h&gt;</code>.  An <code>#ifdef</code> takes care of gcc vs. icc, but clang doesn't seem to provide them anywhere, <a href="http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20160905/170179.html" rel="noreferrer">except in MSVC compatibility mode with <code>-fms-extensions -fms-compatibility -fms-compatibility-version=17.00</code></a>.  And the asm it emits for them sucks (extra masking and a CMOV).</li>
<li>MSVC: <a href="https://msdn.microsoft.com/en-us/library/yy0728bz(v=vs.140).aspx" rel="noreferrer"><code>_rotr8</code> and <code>_rotr16</code></a>.</li>
<li>gcc and icc (not clang):  <code>&lt;x86intrin.h&gt;</code> also provides <code>__rolb</code>/<code>__rorb</code> for 8-bit rotate left/right, <code>__rolw</code>/<code>__rorw</code> (16-bit),  <code>__rold</code>/<code>__rord</code> (32-bit), <code>__rolq</code>/<code>__rorq</code> (64-bit, only defined for 64-bit targets).  For narrow rotates, the implementation uses <code>__builtin_ia32_rolhi</code> or <code>...qi</code>, but the 32 and 64-bit rotates are defined using shift/or (with no protection against UB, because the code in <a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/config/i386/ia32intrin.h#L146" rel="noreferrer"><code>ia32intrin.h</code></a> only has to work on gcc for x86).  GNU C appears not to have any cross-platform <code>__builtin_rotate</code> functions the way it does for <code>__builtin_popcount</code> (which expands to whatever's optimal on the target platform, even if it's not a single instruction).  Most of the time you get good code from idiom-recognition.</li>
</ul>

<p></p>

<pre><code>// For real use, probably use a rotate intrinsic for MSVC, or this idiom for other compilers.  This pattern of #ifdefs may be helpful
#if defined(__x86_64__) || defined(__i386__)

#ifdef _MSC_VER
#include &lt;intrin.h&gt;
#else
#include &lt;x86intrin.h&gt;  // Not just &lt;immintrin.h&gt; for compilers other than icc
#endif

uint32_t rotl32_x86_intrinsic(rotwidth_t x, unsigned n) {
  //return __builtin_ia32_rorhi(x, 7);  // 16-bit rotate, GNU C
  return _rotl(x, n);  // gcc, icc, msvc.  Intel-defined.
  //return __rold(x, n);  // gcc, icc.
  // can't find anything for clang
}
#endif
</code></pre>

<p></p>

<p>Presumably some non-x86 compilers have intrinsics, too, but let's not expand this community-wiki answer to include them all.  (Maybe do that in <a href="https://stackoverflow.com/a/776573/224132">the existing answer about intrinsics</a>).</p>

<hr>

<p>(The old version of this answer suggested MSVC-specific inline asm (which only works for 32bit x86 code), or <a href="http://www.devx.com/tips/Tip/14043" rel="noreferrer">http://www.devx.com/tips/Tip/14043</a> for a C version.  The comments are replying to that.)</p>

<p><strong>Inline asm defeats many optimizations</strong>, <a href="https://stackoverflow.com/questions/3323445/what-is-the-difference-between-asm-and-asm/35959859#35959859">especially MSVC-style because it forces inputs to be stored/reloaded</a>.  A carefully-written GNU C inline-asm rotate would allow the count to be an immediate operand for compile-time-constant shift counts, but it still couldn't optimize away entirely if the value to be shifted is also a compile-time constant after inlining.  <strong><a href="https://gcc.gnu.org/wiki/DontUseInlineAsm" rel="noreferrer">https://gcc.gnu.org/wiki/DontUseInlineAsm</a></strong>.</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/82673/andreast" target="_blank"><span itemprop="name">AndreasT</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/1192487/swap-bits-in-a-number-in-c#answer-0</div>
                                            <div itemprop="upvoteCount">91</div>
                                            <div itemprop="dateCreated">2/9/2019 9:11:27 AM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                            <div id="answer-1" class="block-question second-answer" >
                                <div class="container-question">
                                    <h3 id="popular-answer">Popular Answer</h3>
                                    <div >
                                        <p>Since it's C++, use an inline function:</p>

<pre><code>template &lt;typename INT&gt; 
INT rol(INT val) {
    return (val &lt;&lt; 1) | (val &gt;&gt; (sizeof(INT)*CHAR_BIT-1));
}
</code></pre>

<p>C++11 variant:</p>

<pre><code>template &lt;typename INT&gt; 
constexpr INT rol(INT val) {
    static_assert(std::is_unsigned&lt;INT&gt;::value,
                  "Rotate Left only makes sense for unsigned types");
    return (val &lt;&lt; 1) | (val &gt;&gt; (sizeof(INT)*CHAR_BIT-1));
}
</code></pre>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name"><a href="https://stackoverflow.com/users/15416/msalters" target="_blank">MSalters</a></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/1192487" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/1192487/swap-bits-in-a-number-in-c by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 09:45:54 GMT -->
</html>
