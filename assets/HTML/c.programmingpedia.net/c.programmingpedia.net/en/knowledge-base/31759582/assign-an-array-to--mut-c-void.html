<!DOCTYPE html>



<html lang="en" itemscope="" itemtype="http://schema.org/QAPage">

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/31759582/assign-an-array-to--mut-c-void by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- webmaster tools -->
        <meta name="google-site-verification" content="" />
        <!-- Open Graph Tags -->
        <meta name="title" property="og:title" content="[SOLVED] Assign an array to *mut c_void | C Language Knowledge Base">
        <meta name="description" property="og:description" content="[SOLVED] Assign an array to *mut c_void | C Language Knowledge Base">
        <title>[SOLVED] Assign an array to *mut c_void | C Language Knowledge Base</title>

    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    
        <style>
            body{margin:0;}img{max-width:100%;}ul{margin-top:0;margin-bottom:1rem;}.list-inline{padding-left:0;list-style:none;}.list-inline-item{display:inline-block;}.list-inline-item:not(:last-child){margin-right:.5rem;}.site-header{display:flex;height:60px;}.site-main,.site-footer{display:flex;}.col-aside-left-and-sidebar .col-aside-left,.col-sidebar,.col-content,.col-aside-right{position:relative;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{height:60px;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner{position:fixed;z-index:1;}.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{height:calc(100vh - 60px);position:fixed;}.site-main .col-sidebar-overflow{height:calc(100vh - 60px);position:relative;overflow-x:hidden;overflow-y:auto;}.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 450px);}.col-aside-left,.col-aside-left-inner{width:calc(50% - 750px);}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content,.col-content-inner{width:1200px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 750px);}@media(max-width:1869px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 500px);}.col-aside-left,.col-aside-left-inner{display:none;}.col-sidebar,.col-sidebar-inner{width:calc(50% - 500px);}.col-content,.col-content-inner{width:1000px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 500px);}}@media(max-width:1549px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:calc(50% - 400px);}.col-sidebar,.col-sidebar-inner{width:calc(50% - 400px);}.col-content,.col-content-inner{width:800px;}.col-aside-right,.col-aside-right-inner{width:calc(50% - 400px);}}@media(max-width:1229px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:300px;}.col-sidebar,.col-sidebar-inner{width:300px;}.col-content{width:calc(100% - 300px);}.col-content-inner{width:100%;}.col-aside-right,.col-aside-right-inner{display:none;}}@media(max-width:1000px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{width:250px;}.col-sidebar,.col-sidebar-inner{width:250px;}.col-content{width:calc(100% - 250px);}}@media(max-width:767px){.col-aside-left-and-sidebar,.col-aside-left-and-sidebar-inner{display:none;}.col-sidebar,.col-sidebar-inner{display:none;}.col-content{width:100%;}.site-main{display:initial;}.site-main .col-sidebar,.site-main .col-sidebar-inner{display:initial;width:100%;position:relative;}.site-main .col-sidebar-overflow{height:calc(30vh);}}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-header .col-content-inner{box-shadow:rgba(116,129,141,.1) 0 3px 8px 0;border-bottom:1px solid #d4dadf;}.site-header .col-aside-left-and-sidebar-inner,.site-header .col-aside-right-inner,.site-main .col-aside-left-inner,.site-main .col-sidebar-inner,.site-main .col-aside-right-inner{background:#f5f7f9 none repeat scroll 0% 0%;}.site-header .col-aside-left-and-sidebar-inner,.site-main .col-sidebar-inner{border-right:1px solid #e6ecf1;}.site-header .col-aside-right,.site-main .col-aside-right{border-left:1px solid #e6ecf1;}.brand{font-size:24px;font-weight:bold;height:100%;text-align:right;margin-right:20px;margin-top:10px;}
        </style>
    <link rel="stylesheet" type="text/css" href="../../../styles/master.min0e4d.css?v=todo">
    <!-- to fix/move? -->
    

    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55584370-32"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-131737769-1');
    </script>


</head>
<body>


<div class="site-header">
    <div class="col-aside-left-and-sidebar">
        <div class="col-aside-left-and-sidebar-inner">
            <div class="brand">
                <i class="fas fa-yin-yang" style="color: #0056b3;"></i>&nbsp;
                C Language Pedia
            </div>
        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
<div>
    <ul class="list-inline">
        <li class="list-inline-item"><a href="../../../index.html">Tutorial</a></li>
            <li class="list-inline-item"><a href="../../knowledge-base.html">Knowledge-Base</a></li>

            <li class="list-inline-item"><a href="../../awesome-learning/book.html">Awesome</a></li>
    </ul>
</div>

<style>
    .site-header .col-content .list-inline {
        padding-left: 20px;
        padding-top: 15px;

        font-weight: bold;
    }
</style>
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
            
        </div>
    </div>
</div>
<div class="site-main">
    <div class="col-aside-left">
        <div class="col-aside-left-inner">
            
        </div>
    </div>
    <div class="col-sidebar">
        <div class="col-sidebar-inner">

            <div class="col-sidebar-overflow">
                
            </div>

        </div>
    </div>
    <div class="col-content">
        <div class="col-content-inner">
            


<div id="knowledge-base" class="kb-details">
    <div class="row">
        <div class="col-lg-1 col-xl-1">
        </div>
        <div class="col-lg-9 col-xl-9" itemprop="mainEntity" itemscope itemtype="http://schema.org/Question">
            <div class="container-h1">
                <h1 itemprop="name" id="assign-an-array-to-mut-c-void">Assign an array to *mut c_void</h1>
                <div class="tag-list">
                        <span class="tag-item"><a href="../tag/c.html">c</a></span>
                        <span class="tag-item"><a href="../tag/ffi.html">ffi</a></span>
                        <span class="tag-item"><a href="../tag/rust.html">rust</a></span>
                </div>
            </div>
            <br>
            <div class="search-results-container">
                <div class="row">
                    <div class="col-sm-6">
                        <div class="block-question">
                            <div class="container-question">
                                <i class="fab fa-stack-overflow" style="font-size: 32px; position: absolute; left: -15px; top: -15px;"></i>
                                <h3 id="question">Question</h3>
                                <div itemprop="text">
                                    <p>I am writing bindings for a library, where I have a function with a parameter of type <code>void*</code> aka <code>*mut c_void</code> in Rust. I have to assign an array to this parameter, how can I do this in Rust? </p>

<p>I've tried casting, <code>transmute</code>, it doesn't work (<code>transmute</code> says that <code>c_void</code> and <code>[u8]</code> are of different sizes). If it matters, I am getting the slice from a vector.</p>

<p><strong>UPDATE</strong>: Perhaps it would be correct to somehow use vec.as_mut_ptr() instead?</p>

<p><strong>PLAYPEN</strong>: <a href="http://is.gd/KjgduZ" rel="nofollow">http://is.gd/KjgduZ</a></p>

                                </div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="profile-container">
                                        <div class="profile-details-container d-flex align-items-center">
                                            <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person"><a href="https://stackoverflow.com/users/5180198/zihemu" target="_blank"><span itemprop="name">Zihemu</span></a></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="display: none">
                                    <div itemprop="answerCount">1</div>
                                    <div itemprop="upvoteCount">4</div>
                                    <div itemprop="dateCreated">8/1/2015 2:28:28 PM</div>
                                </div>
                            </div>
                        </div>
                        
                        <br/>
                    </div>
                    <div class="col-sm-6">
                            <div id="answer-0" class="block-question answer" itemprop="acceptedAnswer" itemscope itemtype="http://schema.org/Answer">
                                <div class="container-question">
                                    <h3 id="accepted-answer">Accepted Answer</h3>
                                    <div itemprop="text">
                                        <p>The API you have described looks very suspicious. Remember that there are actually no "arrays" in C - arrays are just another name for pointers to the beginning of multiple values of the same type which are laid continuously in the memory. Therefore, it is impossible to just "assign" an array in C. There are two concepts which may be understood as "assigning" to an array: first, assigning a pointer to the beginning of an array somewhere:</p>

<pre class="lang-c prettyprint-override"><code>const char *s1 = "hello";
const char *s2 = "world";

const char *s = s1;  // make `s` contain a pointer to "hello"
s = s2;  // make `s` contain a pointer to "world"
</code></pre>

<p>Second, it is copying certain pieces of data from one pointer to another, which is usually done with <code>memcpy()</code> or something like it:</p>

<pre class="lang-c prettyprint-override"><code>const char *s1 = "hello";

char s2[5];
memcpy(s2, s1, 5);  // copy 5 bytes from the memory pointed at by `s1` to the memory pointed at by `s2`
</code></pre>

<p>You can probably see now what I mean when I'm saying that your API is suspicious. Your callback function is given a <code>void *</code>, however, there is no indication which "array copy" method should be used.</p>

<p>If it is the first one, i.e. copying the pointer to the beginning of an array, then <code>void *</code> type is extremely unhelpful. It does not say how this pointer should be represented. It looks like that you're trying to do exactly this; however, it won't work as you probably think. Here is a compiling variant of your code (note that it is wrong and will most likely crash your program; see below):</p>

<pre class="lang-rust prettyprint-override"><code>#![feature(libc)]
extern crate libc;

use libc::c_void;

pub extern fn demo(data: *mut *mut c_void) {
    let mut vec = vec!(1, 2, 3);
    unsafe {
        *data = vec.as_mut_ptr() as *mut c_void;
    }
}
</code></pre>

<p>(Note that you can call <code>as_mut_ptr()</code> on a <code>mut</code> variable containing a vector directly due to autoderef)</p>

<p>The parameter type is now not just <code>*mut c_void</code> but <code>*mut *mut c_void</code>, that is, it is a pointer to <code>*mut c_void</code>. This way the program which calls this function could pass a pointer to a local variable of type <code>void *</code> to this function and get a pointer to an actual array, something like</p>

<pre class="lang-c prettyprint-override"><code>void *data;
some_struct.callback_fn(&amp;data);  // pointer to `demo` is stored in `some_struct`
// data is now whatever your `demo` function has assigned
</code></pre>

<p>Note that you just <em>can't</em> sensibly make <code>demo</code> accept just <code>*mut c_void</code> because the only thing you can do with it is to reassign the parameter itself, but reassigning the parameter will reassign only this parameter value, i.e. the local variable this parameter represents. This can't be observed outside of the function. In other words, the following code (which is also a variant of the one you provided):</p>

<pre class="lang-rust prettyprint-override"><code>pub extern fn demo(mut data: *mut c_void) {
    let mut vec = vec!(1, 2, 3);
    data = vec.as_mut_ptr() as *mut c_void;
}
</code></pre>

<p>does nothing, and Rust is glad to point this out:</p>

<pre class="lang-none prettyprint-override"><code>&lt;anon&gt;:6:20: 6:28 warning: variable `data` is assigned to, but never used, #[warn(unused_variables)] on by default
&lt;anon&gt;:6 pub extern fn demo(mut data: *mut c_void) {
                            ^~~~~~~~
&lt;anon&gt;:8:5: 8:9 warning: value assigned to `data` is never read, #[warn(unused_assignments)] on by default
&lt;anon&gt;:8     data = vec.as_mut_ptr() as *mut c_void;
             ^~~~
</code></pre>

<p>The reason I said that the code with <code>*mut *mut c_void</code> is wrong is that it actually violates memory safety. If you create a <code>Vec</code> instance and store it to a local variable, when this variable goes out of scope, the vector itself will be destroyed and the memory it wraps will be freed. Therefore, every pointer obtained from it using <code>as_ptr()</code> or <code>as_mut_ptr()</code> will become invalid.</p>

<p>There are several ways to work this around, the simplest one is to just <code>forget()</code> the vector:</p>

<pre class="lang-rust prettyprint-override"><code>use std::mem;

let mut vec = vec![1, 2, 3];
*data = vec.as_mut_ptr() as *mut c_void;
mem::forget(vec);
</code></pre>

<p>This way the vector is "forgotten" - its destructor won't be called. This way, however, a memory leak is introduced to your program. With each call of <code>demo()</code> a bit more memory will be allocated but not freed, so eventually your program will use all of the available memory and probably crash afterwards. It is a sensible things to do in some context, however, especially in low-level code. For example, your API may specify that it will only call this function once.</p>

<p>Another problem with this approach is a logical consequence of the above one. Your API may specify who should free the memory at the pointer provided to it. For example, it may require passing a memory allocated with <code>malloc()</code> so it then will free it with <code>free()</code> by itself. Or it may specify that you should define another function which will be called when all allocated memory should be freed. Either way is somewhat inconvenient to implement in Rust; I won't go in details on how to do it unless this is indeed your case. Anyway, your API must clearly specify the owner of the memory, and you <em>should</em> take it into account because Rust is much more explicit about ownership.</p>

<p>Another possibility is that your API requires you to copy some data to the memory specified by <code>void *</code> pointer. In other words, its implementation contains a code like this one:</p>

<pre class="lang-c prettyprint-override"><code>char buffer[256];
some_struct.callback_fn(buffer);
</code></pre>

<p>and it expects that after <code>callback_fn</code> invocation the <code>buffer</code> is filled with data.</p>

<p>If this is the case, the API must, naturally, specify the maximum number of bytes in the buffer that your program may use, and your <code>demo</code> function may look like this:</p>

<pre class="lang-rust prettyprint-override"><code>use std::ptr;
use libc::c_void;

pub extern fn demo(data: *mut c_void) {
    let vec: Vec&lt;u8&gt; = vec!(1, 2, 3);
    unsafe { 
        ptr::copy_nonoverlapping(vec.as_ptr(), data as *mut u8, vec.len());
    }
}
</code></pre>

<p>(alternatively, you can convert <code>data</code> to <code>&amp;mut [u8]</code> with <a href="http://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html" rel="noreferrer"><code>std::slice::from_raw_parts_mut()</code></a> and use either <a href="http://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice" rel="noreferrer"><code>clone_from_slice()</code></a> method or <a href="http://doc.rust-lang.org/std/slice/bytes/fn.copy_memory.html" rel="noreferrer"><code>bytes::copy_memory()</code></a> function, but they both are unstable, so they can't be used on stable Rust)</p>

<p>In this case you should be especially careful not to overflow the buffer provided by the calling program to you. Its maximum size should be specified in the API.</p>

<p>Another concern is that copying an array is simple only for byte arrays (<code>char *</code> on C side, <code>&amp;[u8]/&amp;mut [u8]</code> on Rust side). When you start using larger types, like <code>i32</code>, you will get a possibility for portability problems. For example, in <code>C</code> <code>int</code> does not have a defined size, so you just can't blindly convert <code>&amp;[i32]</code> to <code>&amp;[u8]</code> with four times the original size and copy bytes from it to <code>*mut u8</code>. These problems should be taken care of very carefully.</p>

                                    </div>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div class="profile-container">
                                            <div class="profile-details-container d-flex align-items-center">
                                                    <div class="asker-name" itemprop="author" itemscope itemtype="https://schema.org/Person">
                                                        <a href="https://stackoverflow.com/users/788207/vladimir-matveev" target="_blank"><span itemprop="name">Vladimir Matveev</span></a>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                        <div style="display: none">
                                            <div itemprop="url">https://c.programmingpedia.net/en/knowledge-base/31759582/assign-an-array-to--mut-c-void#answer-0</div>
                                            <div itemprop="upvoteCount">6</div>
                                            <div itemprop="dateCreated">8/1/2015 4:55:44 PM</div>
                                        </div>
                                </div>
                            </div>
                            <br/>
                    </div>
                </div>
                <div class="text-center mt-5 mb-5">
                    <a href="https://stackoverflow.com/questions/31759582" class="btn-only d-inline-block stack-overflow-identity" target="_blank"><i class="fab fa-stack-overflow"></i> View more on Stack Overflow</a>
                </div>
            </div>
            
            <div class="attribution">
                <div>Licensed under: <a href="https://creativecommons.org/licenses/by-sa/3.0/" target="_blank">CC-BY-SA</a> with <a href="https://stackoverflow.blog/2009/06/25/attribution-required/" target="_blank">attribution</a></div>
                <div>Not affiliated with: <a href="https://stackoverflow.com/questions/tagged/dapper" target="_blank">Stack Overflow</a></div>
                
            </div>
        </div>

    </div>
</div>
            
        </div>
    </div>
    <div class="col-aside-right">
        <div class="col-aside-right-inner">
        </div>
    </div>
</div>
<div class="site-footer">
</div>
    
    <a href="#" id="scroll-to-top" class="back-to-top" style="display: inline;">Icon</a>

<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="http://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
    $(function() {
        $('a').each(function() {
            var a = new RegExp('/' + window.location.host + '/');
            if (!a.test(this.href)) {
                $(this).attr("target", "_blank");
            }
        });

        $("table").addClass("table table-bordered table-hover table-responsive-sm table-striped");
        $("thead").addClass("thead-dark");

        $('aside a').each(function() {
            if ($(this).attr('href') == '/{{page.permalink}}' ||
                $(this).attr('href') == '{{ site.github.url }}/{{page.permalink}}') {
                $(this).addClass('font-weight-bold');
            }
        });
    });
</script>


</body>

<!-- Mirrored from c.programmingpedia.net/en/knowledge-base/31759582/assign-an-array-to--mut-c-void by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 16 Jan 2021 10:15:14 GMT -->
</html>
