<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--Converted with LaTeX2HTML 97.1 (release) (July 13th, 1997)
 by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippman, Marek Rouchal, Martin Wilck and others -->
<HTML>

<!-- Mirrored from users.cs.cf.ac.uk/Dave.Marshall/C/node24.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 Oct 2020 09:07:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD>
<TITLE>IPC:Interrupts and Signals: &lt;signal.h&gt;</TITLE>
<META NAME="description" CONTENT="IPC:Interrupts and Signals: &lt;signal.h&gt;">
<META NAME="keywords" CONTENT="C">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
<LINK REL="STYLESHEET" HREF="C.css">
</HEAD>
<BODY >
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><strong>Subsections</strong></A>
<UL>
<LI><A NAME="tex2html1196"
 HREF="node24.html#SECTION002410000000000000000">
Sending Signals -- <TT>kill(), raise()</TT></A>
<LI><A NAME="tex2html1197"
 HREF="node24.html#SECTION002420000000000000000">
Signal Handling -- <TT>signal()</TT></A>
<LI><A NAME="tex2html1198"
 HREF="node24.html#SECTION002430000000000000000">
<TT>sig_talk.c</TT> -- complete example program</A>
<LI><A NAME="tex2html1199"
 HREF="node24.html#SECTION002440000000000000000">
Other signal functions</A>
</UL>
<!--End of Table of Child-Links-->
<HR>
<H1><A NAME="SECTION002400000000000000000">
IPC:Interrupts and Signals: &lt;<TT>signal.h</TT>&gt;</A>
</H1>
<A NAME="ch:signal">&#160;</A>
In this section will look at ways in which two processes can communicate. When
a process terminates abnormally it usually tries to send a signal indicating
what went wrong. C programs (and UNIX) can trap these for diagnostics. Also
user specified communication can take place in this way.
<BR>
<P>
Signals are software generated interrupts that are sent to a process when a event happens.
Signals can be synchronously generated by an error in an application, such as <TT>SIGFPE</TT>
and <TT>SIGSEGV</TT>, but most signals are asynchronous. Signals can be posted to a process when
the system detects a software event, such as a user entering an interrupt or stop or a kill
request from another process. Signals can also be come directly from the OS kernel when a
hardware event such as a bus error or an illegal instruction is encountered. The system
defines a set of signals that can be posted to a process. Signal delivery is analogous to
hardware interrupts in that a signal can be blocked from being delivered in the future. Most
signals cause termination of the receiving process if no action is taken by the process in
response to the signal. Some signals stop the receiving process and other signals can be
ignored. Each signal has a default action which is one of the following: 
<UL>
<LI> The signal is
discarded after being received
<LI> The process is terminated after the signal is received
<LI> A
core file is written, then the process is terminated
<LI> Stop the process after the signal is
received
</UL>
<P>
Each signal defined by the system falls into one of five classes:
<P><UL>
<LI> Hardware
conditions
<LI> Software conditions
<LI> Input/output notification
<LI> Process control
<LI>
Resource control
</UL>
<P>
Macros are defined in
<TT>&lt;signal.h&gt;</TT> header file for common signals.
<BR>
<P>
These include:
<P><TABLE CELLPADDING=3>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>SIGHUP  1 /* hangup */</TD>
<TD ALIGN="LEFT" NOWRAP>SIGINT  2 /* interrupt */</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>SIGQUIT 3 /* quit */</TD>
<TD ALIGN="LEFT" NOWRAP>SIGILL  4  /* illegal instruction */</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>SIGABRT 6 /* used by abort */</TD>
<TD ALIGN="LEFT" NOWRAP>SIGKILL 9 /* hard kill */</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>SIGALRM 14 /* alarm clock */</TD>
<TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>SIGCONT 19  /* continue a stopped process */</TD>
<TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>SIGCHLD 20  /* to parent on child stop or exit */</TD>
<TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
</TR>
</TABLE>
<P><EM>Signals</EM> can be numbered from 0 to 31.
<P><H1><A NAME="SECTION002410000000000000000">
Sending Signals -- <TT>kill(), raise()</TT></A>
</H1>
<P>
There are two common functions used to send signals
<P><TT>int kill(int pid, int signal)</TT> - a system call that send a <TT>signal</TT> to a process,
<TT>pid</TT>. If pid is greater than zero, the signal is sent to the  process whose
process ID is equal to pid. If pid is 0, the signal is sent  to  all  processes, 
except system  processes.
<BR>
<P><TT>kill()</TT> returns 0 for a successful call, -1 otherwise and sets <TT>errno</TT>
accordingly.
<BR>
<P><TT>int raise(int sig)</TT> sends the signal sig to the executing program.
<TT>raise()</TT>
 actually  uses <TT>kill()</TT> to send the signal to the executing program:
<P><PRE>
          kill(getpid(), sig);
</PRE>
<P>
There is also a UNIX command called kill that can be used to send signals from the command
line - see <TT>man</TT> pages.
<P><B>NOTE</B>: that unless caught or ignored, the <TT>kill</TT> signal terminates the
process. Therefore protection is built into the system. 
<BR>
<P>
Only processes with certain access
privileges can be killed off.
<BR>
<P>
Basic rule: <EM>only processes that have the same user
can send/receive messages</EM>. 
<BR>
<P>
The <TT>SIGKILL</TT> signal cannot be caught or ignored
and will always terminate a process.
<P>
<BR>
<P>
For example<TT>kill(getpid(),SIGINT);</TT>  would send the interrupt
signal to the id of the calling process. 
<BR>
<P>
This would have a similar effect to
<TT>exit()</TT> command. Also <TT>ctrl-c</TT> typed from the command sends a <TT>
SIGINT</TT> to the process currently being.
<BR>
<P><TT>unsigned int alarm(unsigned int seconds)</TT> -- sends the signal <TT>
SIGALRM</TT> to  the invoking  process  after  seconds seconds.
<P><H1><A NAME="SECTION002420000000000000000">
Signal Handling -- <TT>signal()</TT></A>
</H1>
<P>
An application program can specify a function called a signal handler to be invoked when a specific signal
is received. When a signal handler is invoked on receipt of a signal, it is said to catch the signal. A process
can deal with a signal in one of the following ways:
<UL>
<LI> The process can let the default action happen
<LI> The process can block the signal (some signals cannot be ignored)
<LI> the process can catch the signal with a handler.
</UL>
Signal handlers usually execute on the current stack of the process. This lets the signal handler return to
the point that execution was interrupted in the process. This can be changed on a per-signal basis so that a
signal handler executes on a special stack. If a process must resume in a different context than the
interrupted one, it must restore the previous context itself
<P>
Receiving signals is straighforward with the function:
<P><TT>int (*signal(int sig, void (*func)()))()</TT> -- that is to say the function
<TT>signal()</TT> will call the <TT>func</TT> functions if the process receives a signal
<TT>sig</TT>. Signal returns a pointer to function <TT>func</TT> if successful or it
returns an error to <TT>errno</TT> and -1 otherwise.
<P>
<BR>
<P><TT>func()</TT> can have three values:
<P><DL>
<DT><STRONG><TT>SIG_DFL</TT></STRONG>
<DD>-- a pointer to a system default function <TT>
SID_DFL()</TT>, which will terminate the process upon receipt of <TT>sig</TT>.
<DT><STRONG><TT>SIG_IGN</TT></STRONG>
<DD>-- a pointer to system ignore function <TT>SIG_IGN()</TT>
which will disregard the <TT>sig</TT> action (<U>UNLESS</U> it is <TT>
SIGKILL</TT>).
<DT><STRONG>A function address</STRONG>
<DD>-- a user specified function.
</DL>
<P><TT>SIG_DFL and SIG_IGN</TT> are defined in <TT>signal.h</TT> (standard
library) header file.
<BR>
<P>
Thus to ignore a <TT>ctrl-c</TT> command from the   command line. we could
do:
<BR>
<P>&nbsp;&nbsp;&nbsp;<TT>signal(SIGINT, SIG_IGN);</TT>
<BR>
<P>
TO reset system so that <TT>SIGINT</TT> causes a   termination at any place
in our program, we would do:
<BR>
<P>&nbsp;&nbsp;&nbsp;<TT>signal(SIGINT, SIG_DFL);</TT>
 <BR>
<P>
<BR>
<P>
So lets write a program to trap a <TT>ctrl-c</TT> but not quit on this signal. We
have a function <TT>sigproc()</TT> that is executed when we trap a <TT>
ctrl-c</TT>. We will also set another function to quit the program if it traps the
<TT>SIGQUIT</TT> signal so we can terminate our program:
<BR>
<P><TT>
<PRE><TT>
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
&nbsp;
void sigproc(void);
&nbsp;
void quitproc(void); 
&nbsp;
main()
{		 signal(SIGINT, sigproc);
		 signal(SIGQUIT, quitproc);
		 printf("ctrl-c disabled use ctrl-\\ to quit\n");
		 for(;;); /* infinite loop */}
&nbsp;
void sigproc()
{ 		 signal(SIGINT, sigproc); /*  */
		 /* NOTE some versions of UNIX will reset signal to default
		 after each call. So for portability reset signal each time */
&nbsp;
		 printf("you have pressed ctrl-c \n");
}
&nbsp;
void quitproc()
{ 		 printf("ctrl-\\ pressed to quit\n");
		 exit(0); /* normal exit status */
}
</TT></PRE>
<P></TT>
 <BR>
<P><H1><A NAME="SECTION002430000000000000000">
<TT>sig_talk.c</TT> -- complete example program</A>
</H1>
<P>
Let us now write a program that communicates between child and parent
processes using <TT>kill() and signal()</TT>.
<BR>
<P><TT>fork()</TT> creates the child process from the parent. The <TT>pid</TT> can be
checked to decide whether it is the child (== 0) or the parent (pid = child
process id).
<BR>
<P>
The parent can then send messages to child using the pid and <TT>kill()</TT>.
<BR>
<P>
The child picks up these signals with <TT>signal()</TT> and calls appropriate
functions.
 <BR>
<P>
An example of communicating process using signals is <TT>sig_talk.c</TT>:
<P><PRE>
/* sig_talk.c --- Example of how 2 processes can talk */
/* to each other using kill() and signal() */
/* We will fork() 2 process and let the parent send a few */
/* signals to it`s child  */

/* cc sig_talk.c -o sig_talk  */

#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void sighup(); /* routines child will call upon sigtrap */
void sigint();
void sigquit();

main()
{ int pid;

  /* get child process */
  
   if ((pid = fork()) &lt; 0) {
        perror(&quot;fork&quot;);
        exit(1);
    }
    
   if (pid == 0)
     { /* child */
       signal(SIGHUP,sighup); /* set function calls */
       signal(SIGINT,sigint);
       signal(SIGQUIT, sigquit);
       for(;;); /* loop for ever */
     }
  else /* parent */
     {  /* pid hold id of child */
       printf(&quot;\nPARENT: sending SIGHUP\n\n&quot;);
       kill(pid,SIGHUP);
       sleep(3); /* pause for 3 secs */
       printf(&quot;\nPARENT: sending SIGINT\n\n&quot;);
       kill(pid,SIGINT);
       sleep(3); /* pause for 3 secs */
       printf(&quot;\nPARENT: sending SIGQUIT\n\n&quot;);
       kill(pid,SIGQUIT);
       sleep(3);
     }
}

void sighup()

{  signal(SIGHUP,sighup); /* reset signal */
   printf(&quot;CHILD: I have received a SIGHUP\n&quot;);
}

void sigint()

{  signal(SIGINT,sigint); /* reset signal */
   printf(&quot;CHILD: I have received a SIGINT\n&quot;);
}

void sigquit()

{ printf(&quot;My DADDY has Killed me!!!\n&quot;);
  exit(0);
}
</PRE>
<P><H1><A NAME="SECTION002440000000000000000">
Other signal functions</A>
</H1>
<P>
There are a few other functions defined in <TT>signal.h</TT>:
<P><TT>int sighold(int sig)</TT> -- adds <TT>sig</TT> to the calling process's signal mask
<P><TT>int sigrelse(int sig)</TT> -- removes <TT>sig</TT> from  the  calling  process's  signal
     mask
<P><TT>int sigignore(int sig)</TT> -- sets the disposition of <TT>sig</TT> to <TT>SIG_IGN</TT>
<P><TT>int sigpause(int sig)</TT> -- removes <TT>sig</TT> from  the  calling  process's  signal
     mask  and  suspends  the  calling  process until a signal is
     received
<P>
<BR><HR>
<ADDRESS>
<I>Dave Marshall</I>
<BR><I>1/5/1999</I>
</ADDRESS>
</BODY>

<!-- Mirrored from users.cs.cf.ac.uk/Dave.Marshall/C/node24.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 Oct 2020 09:07:17 GMT -->
</HTML>
