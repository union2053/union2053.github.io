<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--Converted with LaTeX2HTML 97.1 (release) (July 13th, 1997)
 by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippman, Marek Rouchal, Martin Wilck and others -->
<HTML>

<!-- Mirrored from users.cs.cf.ac.uk/Dave.Marshall/C/node31.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 Oct 2020 09:07:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD>
<TITLE>Further Threads Programming:Synchronization</TITLE>
<META NAME="description" CONTENT="Further Threads Programming:Synchronization">
<META NAME="keywords" CONTENT="C">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
<LINK REL="STYLESHEET" HREF="C.css">
</HEAD>
<BODY >
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><strong>Subsections</strong></A>
<UL>
<LI><A NAME="tex2html1382"
 HREF="node31.html#SECTION003110000000000000000">
Mutual Exclusion Locks</A>
<UL>
<LI><A NAME="tex2html1383"
 HREF="node31.html#SECTION003111000000000000000">
Initializing a Mutex Attribute Object</A>
<LI><A NAME="tex2html1384"
 HREF="node31.html#SECTION003112000000000000000">
Destroying a Mutex Attribute Object</A>
<LI><A NAME="tex2html1385"
 HREF="node31.html#SECTION003113000000000000000">
The Scope of a Mutex</A>
<LI><A NAME="tex2html1386"
 HREF="node31.html#SECTION003114000000000000000">
Initializing a Mutex</A>
<LI><A NAME="tex2html1387"
 HREF="node31.html#SECTION003115000000000000000">
Locking a Mutex</A>
<UL>
<LI><A NAME="tex2html1388"
 HREF="node31.html#SECTION003115100000000000000">
Lock with a Nonblocking Mutex</A>
</UL>
<LI><A NAME="tex2html1389"
 HREF="node31.html#SECTION003116000000000000000">
Destroying a Mutex</A>
<LI><A NAME="tex2html1390"
 HREF="node31.html#SECTION003117000000000000000">
Mutex Lock Code
Examples</A>
<UL>
<LI><A NAME="tex2html1391"
 HREF="node31.html#SECTION003117100000000000000">
Mutex Lock Example</A>
<LI><A NAME="tex2html1392"
 HREF="node31.html#SECTION003117200000000000000">
Using Locking Hierarchies: Avoiding Deadlock</A>
</UL>
<LI><A NAME="tex2html1393"
 HREF="node31.html#SECTION003118000000000000000">
Nested Locking with a Singly Linked List</A>
<LI><A NAME="tex2html1394"
 HREF="node31.html#SECTION003119000000000000000">
Solaris Mutex Locks</A>
</UL>
<LI><A NAME="tex2html1395"
 HREF="node31.html#SECTION003120000000000000000">
Condition Variable Attributes</A>
<UL>
<LI><A NAME="tex2html1396"
 HREF="node31.html#SECTION003121000000000000000">
Initializing a Condition Variable Attribute</A>
<LI><A NAME="tex2html1397"
 HREF="node31.html#SECTION003122000000000000000">
Destoying a Condition Variable Attribute</A>
<LI><A NAME="tex2html1398"
 HREF="node31.html#SECTION003123000000000000000">
The Scope of a Condition Variable</A>
<LI><A NAME="tex2html1399"
 HREF="node31.html#SECTION003124000000000000000">
Initializing a Condition Variable</A>
<LI><A NAME="tex2html1400"
 HREF="node31.html#SECTION003125000000000000000">
Block on a Condition Variable</A>
<LI><A NAME="tex2html1401"
 HREF="node31.html#SECTION003126000000000000000">
Destroying a  Condition Variable State</A>
<LI><A NAME="tex2html1402"
 HREF="node31.html#SECTION003127000000000000000">
Solaris Condition Variables</A>
</UL>
<LI><A NAME="tex2html1403"
 HREF="node31.html#SECTION003130000000000000000">
Threads and Semaphores</A>
<UL>
<LI><A NAME="tex2html1404"
 HREF="node31.html#SECTION003131000000000000000">
POSIX Semaphores</A>
<LI><A NAME="tex2html1405"
 HREF="node31.html#SECTION003132000000000000000">
Basic Solaris Semaphore Functions</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>
<H1><A NAME="SECTION003100000000000000000">
Further Threads Programming:Synchronization</A>
</H1>
<P>
When we multiple threads running they will invariably need to communicate with each
other in order <EM>synchronise</EM> their execution. This chapter describes the
synchronization types available with  threads and discusses when and how to use
synchronization.
<P>
There are a few possible methods of synchronising threads:
<UL>
<LI> Mutual Exclusion (Mutex) Locks
<LI> Condition Variables
<LI> Semaphores 
</UL>
<P>
We wil frequently make use of <EM>Synchronization objects</EM>: these are variables in
memory that you access just like data. Threads in different processes can communicate
with each other through synchronization objects placed in threads-controlled shared
memory, even though the threads in different processes are generally invisible to each
other.
<P>
Synchronization objects can also be placed in files and can have lifetimes
beyond that of the creating process.
<P>
Here are some example situations that require or can
profit from the use of synchronization: 
<UL>
<LI> When synchronization is the only way to
ensure consistency of shared data.
<LI> When threads in two or more processes can use a
single synchronization object jointly. Note that the synchronization object should be
initialized by only one of the cooperating processes, because reinitializing a
synchronization object sets it to the unlocked state.
<LI> When synchronization can ensure
the safety of mutable data.
<LI> When a process can map a file and have a thread in this
process get a record's lock. Once the lock is acquired, any other thread in any process
mapping the file that tries to acquire the lock is blocked until the lock is released.
<LI> Even when accessing a single primitive variable, such as an integer. On machines
where the integer is not aligned to the bus data width or is larger than the data
width, a single memory load can use more  than one memory cycle. While this cannot
happen on the SPARC architectures, portable programs cannot rely on this.
<P></UL><H1><A NAME="SECTION003110000000000000000">
Mutual Exclusion Locks</A>
</H1>
<P>
Mutual exclusion locks (mutexes) are a comon method of serializing thread execution.
Mutual exclusion locks synchronize threads, usually by ensuring that only one thread at
a time executes a critical section of code. Mutex locks can also preserve
single-threaded code.
<P>
Mutex attributes may be associated with every thread. To change the default mutex
attributes, you can declare and initialize an mutex attribute object and then alter
specific values much like we have seen in the last chapter on more general POSIX
attributes. Often, the mutex attributes are set in one place at the beginning of the
application so they can be located quickly and modified easily.
<P>
After the attributes for a
mutex are configured, you initialize the mutex itself. Functions are available
to initialize or destroy, lock or unlock, or try to lock a mutex.
<P><H2><A NAME="SECTION003111000000000000000">
Initializing a Mutex Attribute Object</A>
</H2>
<P>
The function <TT>pthread_mutexattr_init()</TT> is used
to initialize attributes associated with this object to their default values. It is
prototyped by:
<P><PRE>
int pthread_mutexattr_init(pthread_mutexattr_t *mattr);
</PRE>
<P>
Storage
for each attribute object is allocated by the threads system during execution. <TT>mattr</TT> is an opaque type that contains a system-allocated attribute object. The
possible values of mattr's scope are <TT>PTHREAD_PROCESS_PRIVATE</TT> (the default) and
<TT>PTHREAD_PROCESS_SHARED</TT>.The
default value of the pshared attribute when this function is called is
<TT>PTHREAD_PROCESS_PRIVATE</TT>, which means that the initialized mutex can be used
within a process.
<P>
Before a mutex attribute object can be reinitialized, it must
first be destroyed by <TT>pthread_mutexattr_destroy()</TT> (see below). The
<TT>pthread_mutexattr_init()</TT> call returns a pointer to an opaque object. If the
object is not destroyed, a memory leak will result. <TT>
pthread_mutexattr_init()</TT> returns zero after completing successfully. Any other
returned value indicates that an error occurred.
<P>
A simple example of this function call is:
<P><PRE>
#include &lt;pthread.h&gt;

pthread_mutexattr_t mattr; 
int ret; 

/* initialize an attribute to default value */ 

ret = pthread_mutexattr_init(&amp;mattr);
</PRE>
<P>  <H2><A NAME="SECTION003112000000000000000">
Destroying a Mutex Attribute Object</A>
</H2>
<P>
The function 
<TT>pthread_mutexattr_destroy()</TT> deallocates the storage space used to maintain the
attribute object created by <TT>pthread_mutexattr_init()</TT>. It is prototyped by:
<P><PRE>
int pthread_mutexattr_destroy(pthread_mutexattr_t *mattr);
</PRE>
<P>
which returns zero
after completing successfully. Any other returned value indicates that an error
occurred.
<P>
The function is called as follows:
<P><PRE>
#include &lt;pthread.h&gt;

pthread_mutexattr_t mattr; 
int ret; 

/* destroy an attribute */ 
ret = pthread_mutexattr_destroy(&amp;mattr);
</PRE>
<P><H2><A NAME="SECTION003113000000000000000">
The Scope of a Mutex</A>
</H2>
<P>
The scope of a mutex
variable can be either process private (intraprocess) or system wide (interprocess).
The function <TT>pthread_mutexattr_setpshared()</TT> is used to set the scope of
a mutex atrribute and it is prototype as follows:
<P><PRE>
int pthread_mutexattr_setpshared(pthread_mutexattr_t *mattr, int pshared);
</PRE>
<P>
If
the mutex is created with the <TT>pshared</TT> (POSIX) attribute set to the
<TT>PTHREAD_PROCESS_SHARED</TT> state, and it exists in shared memory, it can be shared
among threads from more than one process. This is equivalent to the
 <TT>USYNC_PROCESS</TT> flag in <TT>mutex_init()</TT> in  Solaris
threads. 
If the mutex <TT>pshared</TT>
attribute is set to <TT>PTHREAD_PROCESS_PRIVATE</TT>, only those threads created by the
same process can operate on the mutex. This is equivalent to the
 <TT>USYNC_THREAD</TT> flag in <TT>mutex_init()</TT> in  Solaris
threads.
<P><TT>pthread_mutexattr_setpshared()</TT> returns zero after completing successfully. Any
other returned value indicates that an error occurred.
<P>
A simple example call is:
<P><PRE>
#include &lt;pthread.h&gt; 

pthread_mutexattr_t mattr; 
int ret; 

ret = pthread_mutexattr_init(&amp;mattr); 

/* resetting to its default value: private */
ret = pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_PRIVATE);
</PRE>
<P>
The function <TT>
pthread_mutexattr_getpshared(pthread_mutexattr_t *mattr, int *pshared)</TT> may be used
to obtain the scope of a current thread mutex as follows:
<P><PRE>
 #include &lt;pthread.h&gt;
pthread_mutexattr_t mattr; 
int pshared, ret; 

/* get pshared of mutex */ ret =
pthread_mutexattr_getpshared(&amp;mattr, &amp;pshared);
</PRE>
<P><H2><A NAME="SECTION003114000000000000000">
Initializing a Mutex</A>
</H2>
<P>
The function <TT>
pthread_mutex_init()</TT> to initialize the mutex, it is prototyped by:
<P><PRE>
int pthread_mutex_init(pthread_mutex_t *mp, const pthread_mutexattr_t *mattr);
</PRE>
<P>
Here, <TT>pthread_mutex_init()</TT> initializes the mutex pointed at by <TT>mp </TT> to its
default value if <TT>mattr</TT> is <TT>NULL</TT>, or to specify mutex attributes that have
already been set with <TT>pthread_mutexattr_init()</TT>.
<P>
A mutex lock must not be reinitialized or destroyed while other
threads might be using it. Program failure will result if either action is not done
correctly. If a mutex is reinitialized or destroyed, the application must be sure the
mutex is not currently in use. <TT>pthread_mutex_init()</TT> returns zero after
completing successfully. Any other returned value indicates that an error occurred.
<P>
A simple example call is:
<P><PRE>
#include &lt;pthread.h&gt;

pthread_mutex_t mp = PTHREAD_MUTEX_INITIALIZER; 
pthread_mutexattr_t mattr; 
int ret; 

/* initialize a mutex to its default value */ 
ret = pthread_mutex_init(&amp;mp, NULL);
</PRE>
<P>
When the mutex is
initialized, it is in an unlocked state. The effect of <TT>mattr</TT> being <TT>NULL</TT> is
the same as passing the address of a default mutex attribute object, but without the
memory overhead. Statically defined mutexes can be initialized directly to have default
attributes with the macro <TT>PTHREAD_MUTEX_INITIALIZER</TT>.
<P>
To initialise a mutex with non-default values do something like:
<PRE>
/* initialize a mutex attribute */ 
ret = pthread_mutexattr_init(&amp;mattr);

/* change mattr default values with some function */
 ret = pthread_mutexattr_*();

/* initialize a mutex to a non-default value */
ret = pthread_mutex_init(&amp;mp, &amp;mattr);
</PRE>
<P><H2><A NAME="SECTION003115000000000000000">
Locking a Mutex</A>
</H2>
<P>
The function <TT>pthread_mute_lock()</TT> is used to lock a mutex, it is prototyped by:
<P><PRE>
int pthread_mutex_lock(pthread_mutex_t *mp);
</PRE>
<P><TT>pthread_mute_lock()</TT> locks the mutex pointed to by <TT>mp</TT>. When the mutex is
already locked, the calling thread blocks and the mutex waits on a prioritized queue.
When <TT>pthread_mute_lock()</TT> returns, the mutex is locked and the calling thread
is the owner. <TT>pthread_mute_lock()</TT> returns zero after completing successfully.
Any other returned value indicates that an  error occurred.
<P>
Therefor to lock a mutex <TT>mp</TT> on would do the following:
<P><PRE>
#include &lt;pthread.h&gt; 
pthread_mutex_t mp; 
int ret; 

ret = pthread_mutex_lock(&amp;mp);
</PRE>
<P>
To unlock a  mutex use the function <TT>pthread_mutex_unlock()</TT> 
whose prototype is:
<P><PRE>
int pthread_mutex_unlock(pthread_mutex_t *mp);
</PRE>
<P>
Clearly, this function unlocks the mutex
pointed to by <TT>mp</TT>.
<P>
The mutex must be locked and the calling thread <B>must</B> be the one that last
locked the mutex (<EM>i.e. the owner</EM>). When any other threads are waiting for the
mutex to become available, the thread at the head of the queue is unblocked. <TT>
pthread_mutex_unlock()</TT>  returns zero after completing successfully. Any other
returned value indicates that an error occurred.
<P>
A simple example call of <TT>pthread_mutex_unlock()</TT>  is:
<P><PRE>
#include &lt;pthread.h&gt; 

pthread_mutex_t mp; 
int ret; 

/* release the mutex */ 
ret = pthread_mutex_unlock(&amp;mp);
</PRE>
<P><H3><A NAME="SECTION003115100000000000000">
Lock with a Nonblocking Mutex</A>
</H3>
<P>
The function <TT>pthread_mutex_trylock()</TT> to
attempt to lock the mutex and is prototyped by:
<P><PRE>
int pthread_mutex_trylock(pthread_mutex_t *mp);
</PRE>
<P>
This function attempts  to lock the mutex pointed to by <TT>mp</TT>. <TT>
pthread_mutex_trylock()</TT> is a nonblocking version of <TT>pthread_mutex_lock()</TT>.
When the mutex is already locked, this call returns with an error. Otherwise, the mutex
is locked and the calling thread is the owner. <TT>pthread_mutex_trylock()</TT>
returns zero after completing successfully. Any other returned value indicates that an
error occurred.
<P>
The function is called as follows:
<P><PRE>
#include &lt;pthread.h&gt; 
pthread_mutex_t mp;

/* try to lock the mutex */
int ret; ret = pthread_ mutex_trylock(&amp;mp);
</PRE>
<P><H2><A NAME="SECTION003116000000000000000">
Destroying a Mutex</A>
</H2>
<P>
The function <TT>pthread_mutex_destroy()</TT> may be used to destroy any state
associated with the mutex. It is prototyped by:
<P><PRE>
int pthread_mutex_destroy(pthread_mutex_t *mp);
</PRE>
<P>
and destroys a mutex pointed to by mp.
<P><B>Note</B>: that the
space for storing the mutex is not freed. <TT>pthread_mutex_destroy()</TT> returns
zero after completing successfully. Any other returned value indicates that an error
occurred.
<P>
It is called by:
<P><PRE>
#include &lt;pthread.h&gt; 
pthread_mutex_t mp;
int ret; 

/* destroy mutex */
ret = pthread_mutex_destroy(&amp;mp);
</PRE>
<P><H2><A NAME="SECTION003117000000000000000">
Mutex Lock Code
Examples</A>
</H2>
<P>
Here are some code fragments showing mutex locking.
<P><H3><A NAME="SECTION003117100000000000000">
Mutex Lock Example</A>
</H3>
<P>
We develop two small functions that use the mutex lock for
different purposes.
<P><UL>
<LI> The <TT>increment_count function()</TT> uses the mutex lock simply to ensure
an atomic update of the shared variable, <TT>count</TT>.
<LI> The <TT>get_count()</TT> function uses the
mutex lock to guarantee that the (<TT>long long</TT>) 64-bit quantity count is read
atomically. On a 32-bit architecture, a long long is really two 32-bit quantities.
</UL>
<P>
The 2 functions are as follows:
<P><PRE>
#include &lt;pthread.h&gt; 
pthread_mutex_t count_mutex; 
long long count; 

void increment_count() 
   { pthread\_mutex\_lock(&amp;count_mutex); 
     count = count + 1;
     pthread_mutex_unlock(&amp;count_mutex); 
   }   


long long get_count()  
   { long long c;
     pthread\_mutex\_lock(&amp;count_mutex); 
     c = count; 
     pthread_mutex_unlock(&amp;count_mutex);
     return (c); 
    }
</PRE>
<P><B>Recall</B> that 
reading an integer value is an atomic operation because integer is the common word size
on most machines.
<P><H3><A NAME="SECTION003117200000000000000">
Using Locking Hierarchies: Avoiding Deadlock</A>
</H3>
<P>
You may occasionally want to access two
resources at once. For instance, you are using one of the resources, and then discover
that the other resource is needed as well. However, there could be a problem
if two threads attempt to claim both resources but lock the associated mutexes in
different orders.
<P>
In this example, if the two threads lock mutexes 1 and 2
respectively, then a <EM>deadlock</EM> occurs when each attempts to lock the other mutex.
<P><TABLE CELLPADDING=3 BORDER="1">
<TR VALIGN="TOP"><TH ALIGN="LEFT" NOWRAP><B>Thread 1</B></TH>
<TH ALIGN="LEFT" NOWRAP><B>Thread 2</B></TH>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP><TT>/* use resource 1 */ </TT></TD>
<TD ALIGN="LEFT" NOWRAP><TT>/* use resource 2 */</TT></TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP><TT>pthread_mutex_lock(&amp;m1);</TT></TD>
<TD ALIGN="LEFT" NOWRAP><TT>pthread_mutex_lock(&amp;m2);</TT></TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP><TT>/* NOW use resources  2 + 1 */</TT></TD>
<TD ALIGN="LEFT" NOWRAP><TT>/* NOW use resources 1 + 2 */</TT></TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP><TT>pthread_mutex_lock(&amp;m2);</TT></TD>
<TD ALIGN="LEFT" NOWRAP><TT>pthread_mutex_lock(&amp;m1);</TT></TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP>&nbsp;</TD>
</TR>
<TR VALIGN="TOP"><TD ALIGN="LEFT" NOWRAP><TT>pthread_mutex_lock(&amp;m1);</TT></TD>
<TD ALIGN="LEFT" NOWRAP><TT>pthread_mutex_lock(&amp;m2);</TT></TD>
</TR>
</TABLE>
<P>
The best way to avoid this problem is to make sure that
whenever threads lock multiple mutexes, they do so in the same order. This technique is
known as lock hierarchies: order the mutexes by logically assigning numbers to them.
Also, honor the restriction that you cannot take a mutex that is assigned n when you
are holding any mutex assigned a number greater than n.
<P><B>Note</B>: The <TT>lock_lint</TT> tool can
detect the sort of deadlock problem shown in this example.
<P>
The best  way to avoid such
deadlock problems is to use lock hierarchies. When locks are always taken in a
prescribed order, deadlock should not occur. However, this technique cannot always be
used :
<P><UL>
<LI> sometimes you must take the mutexes in an order other than prescribed.
<LI> To prevent deadlock in such a situation, use <TT>pthread_mutex_trylock()</TT>. One
thread must release its mutexes when it discovers that deadlock would otherwise be
inevitable.
</UL>
<P>
The idea of <EM>Conditional Locking</EM> use this approach:
<P><B>Thread 1</B>:
<P><PRE>
pthread_mutex_lock(&amp;m1); 
pthread_mutex_lock(&amp;m2); 

/* no processing */
pthread_mutex_unlock(&amp;m2);
pthread_mutex_unlock(&amp;m1);
</PRE>
<P><B>Thread 2</B>:
<P><PRE>
for (; ;) {
  pthread_mutex_lock(&amp;m2); 
  if(pthread_mutex_trylock(&amp;m1)==0) 
    /* got it! */ 
    break; 
 /* didn't get it */ 
 pthread_mutex_unlock(&amp;m2); 
 } 
/* get locks; no processing */
pthread_mutex_unlock(&amp;m1); 
pthread_mutex_unlock(&amp;m2);
</PRE>
<P>
In the above example, thread 1 locks
mutexes in the prescribed order, but thread 2 takes them out of order. To make certain
that there is no deadlock, thread 2 has to take mutex 1 very carefully; if it were to
block waiting for the mutex to be released, it is likely to have just entered into a
deadlock with thread 1. To ensure this does not happen, thread 2 calls
<TT>pthread_mutex_trylock()</TT>, which takes the mutex if it is available. If it is not,
thread 2 returns immediately, reporting failure. At this point, thread 2 must release
mutex 2, so that thread 1 can lock it, and then release both mutex 1 and mutex 2.
<P><H2><A NAME="SECTION003118000000000000000">
Nested Locking with a Singly Linked List</A>
</H2>
<P>
We have met basic linked structues in Section&nbsp;<A HREF="node11.html#sec:linklist">10.3</A>, when using threads
which share a linked list structure the possibility of deadlock may arise.
<P>
By nesting mutex locks into the linked data structure and a simple ammendment of the
link list code we can  prevent deadlock by
taking the locks in a prescribed order.
<P>
The modified linked is as follows:
<P><PRE>
typedef struct node1 { 
     int value; 
     struct node1 *link;
     pthread_mutex_t lock; 
   } node1_t;
</PRE>
<P><B>Note:</B> we simply ammend a standard
singly-linked list structure so that each node containing a mutex.
<P>
Assuming we have created a variable <code>node1_t ListHead</code>.
<P>
To remove a node from
the list:
<UL>
<LI> first search the list starting at ListHead (which itself is never
removed) until the desired node is found.
<LI> To protect this search from the effects of
concurrent deletions, lock each node before any of its contents are accessed.
<P>
Because
all searches start at ListHead, there is never a deadlock because the locks are always
taken in list order.
<LI> When the desired node is found, lock both the node and its
predecessor since the change involves both nodes.
<P>
Because the predecessor's lock is
always taken first, you are again protected from deadlock. 
</UL>
<P>
The C code to remove an item from a singly linked list with nested locking is as
follows:
<P><PRE>
 

node1_t *delete(int value) 
  { node1_t *prev,
    *current; prev = &amp;ListHead;
 
   pthread_mutex_lock(&amp;prev-&gt;lock); 
   while ((current = prev-&gt;link) != NULL) 
     { pthread_mutex_lock(&amp;current-&gt;lock); 
       if (current-&gt;value == value) 
         { prev-&gt;link = current-&gt;link;
           pthread_mutex_unlock(&amp;current-&gt;lock); 
           pthread_mutex_unlock(&amp;prev-&gt;lock);
           current-&gt;link = NULL; return(current); 
         } 
       pthread_mutex_unlock(&amp;prev-&gt;lock);
       prev = current; 
      } 
    pthread_mutex_unlock(&amp;prev-&gt;lock); 
    return(NULL); 
   }
</PRE>
<P><H2><A NAME="SECTION003119000000000000000">
Solaris Mutex Locks</A>
</H2>
<A NAME="sec:sol_mutex">&#160;</A>
Similar mutual
exclusion locks exist for in Solaris.
<P>
You should include the &lt;synch.h&gt; or  &lt;thread.h&gt;libraries.
<P>
To initialize a mutex  use <TT>int mutex_init(mutex_t *mp, int type, void *arg))</TT>.
<TT>mutex_init()</TT> initializes the mutex pointed to by <TT>mp</TT>.  The <TT>type</TT> can be
one of the following (note that <TT>arg</TT>  is currently ignored).
<P><DL>
<DT><STRONG><TT>USYNC_PROCESS</TT></STRONG>
<DD>-- The
mutex can be used to synchronize threads in this and other processes.
<DT><STRONG><TT>USYNC_THREAD</TT></STRONG>
<DD>-- The
mutex can be used to synchronize threads in this process, only. 
</DL>
<P>
Mutexes can also be
initialized by allocation in zeroed memory, in which case a type of <TT>USYNC_THREAD</TT>
is assumed.  Multiple threads must not
initialize the same mutex simultaneously. A mutex lock must not be reinitialized while
other threads might be using it.
<P>
The function <TT>int mutex_destroy (mutex_t *mp)</TT>
 destroys any state associated with the mutex pointed to by <TT>mp</TT>. <B>Note</B>
that the space for storing the mutex is not freed.
<P>
To acquire a mutex lock use the function <TT>mutex_lock(mutex_t *mp)</TT>
which  locks the mutex pointed to by mp. When the mutex is already locked,
the calling thread blocks until the mutex becomes available (blocked threads wait on a
prioritized queue).
<P>
To release a mutex use <TT>mutex_unlock(mutex_t *mp)</TT> which unlocks the
mutex pointed to by mp. The mutex must be locked and the calling thread must be the one
that last locked the mutex (the owner).
<P>
To try to acquire a mutex use mutex_trylock(mutex_t *mp) to attempt to
lock the mutex pointed to by <TT>mp</TT>. This function is a nonblocking version of
<TT>mutex_lock()</TT>
<P><H1><A NAME="SECTION003120000000000000000">
Condition Variable Attributes</A>
</H1>
<P>
Condition variables can be usedto atomically block
threads until a particular condition is true. Condition variables are <EM>always</EM> used
in conjunction with  mutex locks:
<P><UL>
<LI> With a condition variable, a thread can atomically
block until a condition is satisfied.
<LI> The condition is tested under the protection of a
mutual exclusion lock (mutex). 
<UL>
<LI> When the condition is false, a thread usually blocks on a
condition variable and atomically releases the mutex waiting for the condition to
change.
<LI> When another thread changes the condition, it can signal the associated
condition variable to cause one or more waiting threads to wake up, acquire the mutex
again, and reevaluate the condition. 
</UL></UL>
<P>
Condition variables can be used to synchronize
threads among processes when they are allocated in memory that can be written to and is
shared by the cooperating processes.
<P>
The
scheduling policy determines how blocking threads are awakened. For the default
<TT>SCHED_OTHER</TT>, threads are awakened in priority order. The attributes for condition
variables must be set and initialized before the condition variables can be used.
<P>
As with mutex locks, The condiotion variable attributes must be initialised  and set (or set
to <TT>NULL</TT>) before an actual condition variable may be initialise (with
appropriat attributes) and then used.
<P><H2><A NAME="SECTION003121000000000000000">
Initializing a Condition Variable Attribute</A>
</H2>
<P>
The function   <TT>pthread_condattr_init()</TT>  initializes attributes associated with
this object to their default values. It is prototyped by:
<P><PRE>
int pthread_condattr_init(pthread_condattr_t *cattr);
</PRE>
<P>
Storage for each attribute object, <TT>cattr</TT>, is allocated by
the threads system during execution. <TT>cattr</TT> is an opaque data type that contains a
system-allocated attribute object. The possible values of cattr's scope are
<TT>PTHREAD_PROCESS_PRIVATE</TT>  and <TT>PTHREAD_PROCESS_SHARED</TT>. The default value
of the pshared attribute when this function is called is <TT>
PTHREAD_PROCESS_PRIVATE</TT>, which means that the initialized condition variable can be
used within a process.
<P>
Before a condition variable attribute can be reused, it must
first be reinitialized by <TT>pthread_condattr_destroy()</TT>. The
<TT>pthread_condattr_init()</TT> call returns a pointer to an opaque object. If the
object is not destroyed, a memory leak will result.
<P><TT>pthread_condattr_init()</TT>  returns zero
after completing successfully. Any other returned value indicates that an error
occurred. When either of the following conditions occurs, the function fails and
returns the corresponding value.
<P>
A simple example call of this function is :
<P><PRE>
#include &lt;pthread.h&gt;

pthread_condattr_t cattr; 
int ret; 

/* initialize an attribute to default value */ 
ret = pthread_condattr_init(&amp;cattr);
</PRE>
<P><H2><A NAME="SECTION003122000000000000000">
Destoying a Condition Variable Attribute</A>
</H2>
<P>
The function <TT>pthread_condattr_destroy()</TT>  removes storage and renders
the attribute object invalid, it is prototyped by:
<P><PRE>
int pthread_condattr_destroy(pthread_condattr_t *cattr);
</PRE>
<P><TT>pthread_condattr_destroy()</TT>   returns zero
after completing successfully and destroying the condition variable pointed to by <TT>
cattr</TT>. Any other returned value indicates that an error occurred. If the following
condition occurs, the function fails and returns the corresponding value.
<P><H2><A NAME="SECTION003123000000000000000">
The Scope of a Condition Variable</A>
</H2>
<P>
The scope of a condition variable can be either process
private (intraprocess) or system wide (interprocess), as with mutex locks. If the
condition variable is created with the pshared attribute set to the
<TT>PTHREAD_PROCESS_SHARED</TT> state, and it exists in shared memory, it can be shared
among threads from more than one process. This is equivalent to the <TT>USYNC_PROCESS</TT>
flag in <TT>mutex_init()</TT> in the original Solaris threads. If the mutex pshared
attribute is set to <TT>PTHREAD_PROCESS_PRIVATE</TT> (default value), only those threads
created by the same process can operate on the mutex. Using <TT>
PTHREAD_PROCESS_PRIVATE</TT> results in the same behavior as with the <TT>USYNC_THREAD</TT>
flag in the original Solaris threads <TT>cond_init()</TT> call, which is that of a local
condition variable. <TT>PTHREAD_PROCESS_SHARED</TT> is equivalent to a global condition
variable.
<P>
The function <TT>pthread_condattr_setpshared()</TT> is used to set the scope of a
condition variable, it is  prototyped by:
<P><PRE>
int pthread_condattr_setpshared(pthread_condattr_t *cattr, int pshared);
</PRE>
<P>
The condition variable attribute <TT>cattr</TT> must be initialised first and the value of
<TT>pshared</TT> is either <TT>PTHREAD_PROCESS_SHARED</TT> or <TT>
PTHREAD_PROCESS_PRIVATE</TT>.
<P><TT>pthread_condattr_setpshared()</TT>  returns zero after completing successfully. Any
other returned value indicates that an error occurred.
<P>
A sample use of this function is as follows:
<P><PRE>
#include &lt;pthread.h&gt; 

pthread_condattr_t cattr; 
int ret; 

/* Scope: all processes */ 
ret = pthread_condattr_setpshared(&amp;cattr, PTHREAD_PROCESS_SHARED); 

/* OR */
/* Scope: within a process */ 
ret = pthread_condattr_setpshared(&amp;cattr, PTHREAD_PROCESS_PRIVATE);
</PRE>
<P>
The function <TT>int pthread_condattr_getpshared(const pthread_condattr_t *cattr,
int *pshared)</TT> may be used to obtain the scope of a given condition variable.
<P> <H2><A NAME="SECTION003124000000000000000">
Initializing a Condition Variable</A>
</H2>
<P>
The function <TT>pthread_cond_init()</TT>  initializes the condition variable and
is prototyped as follows:
<P><PRE>
int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);
</PRE>
<P>
The condition variable which is initialized is  pointed at by <TT>cv</TT> and is set to its
default value if <TT>cattr</TT> is <TT>NULL</TT>, or to specific <TT>cattr</TT> condition
variable attributes that are already set with <TT>pthread_condattr_init()</TT>. 
The
effect of <TT>cattr</TT> being NULL is the same as passing the address of a default
condition variable attribute object, but without the memory overhead.
<P>
Statically-defined condition variables can be initialized directly to have default
attributes with the macro <TT>PTHREAD_COND_INITIALIZER</TT>. This has the same effect as
dynamically allocating <TT>pthread_cond_init()</TT> with null attributes. No error
checking is done. Multiple threads must not simultaneously initialize or reinitialize
the same condition variable. If a condition variable is reinitialized or destroyed, the
application must be sure the condition variable is not in use.
<P><TT>pthread_cond_init()</TT> returns zero after completing successfully. Any other
returned value indicates that an error occurred.
<P>
Sample calls of this function are:
<P><PRE>
#include &lt;pthread.h&gt; 

pthread_cond_t cv; 
pthread_condattr_t cattr; 
int ret; 

/* initialize a condition variable to its default value */ 
ret = pthread_cond_init(&amp;cv, NULL); 

/* initialize a condition variable */ ret =
pthread_cond_init(&amp;cv, &amp;cattr);
</PRE>
<P><H2><A NAME="SECTION003125000000000000000">
Block on a Condition Variable</A>
</H2>
<P>
The function <TT>pthread_cond_wait()</TT> is used to atomically release a mutex and to
cause the calling thread to block on the condition variable. It is protoyped by:
<P><PRE>
int pthread_cond_wait(pthread_cond_t *cv,pthread_mutex_t *mutex);
</PRE>
<P>
The mutex that is released is pointed
to by <TT>mutex</TT> and  the condition variable
pointed to by <TT>cv</TT> is blocked.
<P><TT>pthread_cond_wait()</TT> returns zero after completing successfully. Any other
returned value indicates that an error occurred. When the following condition occurs,
the function fails and returns the corresponding value.
<P>
A simple example call is:
<P><PRE>
#include &lt;pthread.h&gt; 

pthread_cond_t cv; 
pthread_mutex_t mutex; 
int ret; 

/* wait on condition variable */ 
ret = pthread_cond_wait(&amp;cv, &amp;mutex);
</PRE>
<P>
The blocked thread
can be awakened by a <TT>pthread_cond_signal()</TT>, a <TT>pthread_cond_broadcast()</TT>,
or when interrupted by delivery of a signal. Any change in the value of a condition
associated with the condition variable cannot be inferred by the return of
<TT>pthread_cond_wait()</TT>, and any such condition must be reevaluated. The
<TT>pthread_cond_wait()</TT> routine always returns with the mutex locked and owned by
the calling thread, even when returning an error. This function blocks until the
condition is signaled. It atomically releases the associated mutex lock before
blocking, and atomically acquires it again before returning. In typical use, a
condition expression is evaluated under the protection of a mutex lock. When the
condition expression is false, the thread blocks on the condition variable. The
condition variable is then signaled by another thread when it changes the condition
value. This causes one or all of the threads waiting on the condition to unblock and to
try to acquire the mutex lock again. Because the condition can change before an
awakened thread returns from <TT>pthread_cond_wait()</TT>, the  condition that
caused the wait must be retested before the mutex lock is acquired.
<P>
The recommended
test method is to write the condition check as a while loop that calls
<TT>pthread_cond_wait()</TT>, as follows:
<P><PRE>
pthread_mutex_lock();

while(condition_is_false) 
  pthread_cond_wait(); 
pthread_mutex_unlock();
</PRE>
<P>
No specific
order of acquisition is guaranteed when more than one thread blocks on the condition
variable. Note also that <TT>pthread_cond_wait()</TT> is a cancellation point. If a
cancel is pending and the calling thread has cancellation enabled, the thread
terminates and begins executing its cleanup handlers while continuing to hold the lock.
<P>
To unblock a specific thread use
<TT>pthread_cond_signal()</TT> which is prototyped by:
<P><PRE>
int pthread_cond_signal(pthread_cond_t *cv);
</PRE>
<P>
This unblocks one thread that is blocked on the condition
variable pointed to by <TT>cv</TT>. <TT>
pthread_cond_signal()</TT> returns zero after completing successfully. Any other returned
value indicates that an error occurred.
<P>
You should always call <TT>pthread_cond_signal()</TT> under the protection of the
same mutex used with the condition variable being signaled. Otherwise, the condition
variable could be signaled between the test of the associated condition and blocking in
<TT>pthread_cond_wait()</TT>, which can cause an infinite wait. The scheduling policy
determines the order in which blocked threads are awakened. For <TT>SCHED_OTHER</TT>,
threads are awakened in priority order. When no threads are blocked on the condition
variable, then calling <TT>pthread_cond_signal()</TT>l has no effect.
<P>
The folloowing code fragment illustrates how to avoid an infinite problem
described above:
<P><PRE>
pthread_mutex_t count_lock; 
pthread_cond_t count_nonzero; 
unsigned count; 

decrement_count() 
   { pthread_mutex_lock(&amp;count_lock); 

     while (count == 0) 
        pthread_cond_wait(&amp;count_nonzero, &amp;count_lock); 
     count = count - 1; 
     pthread_mutex_unlock(&amp;count_lock); 
   } 

increment_count() 
   { pthread_mutex_lock(&amp;count_lock); 
     if (count == 0)
       pthread_cond_signal(&amp;count_nonzero); 
     count = count + 1;
     pthread_mutex_unlock(&amp;count_lock); 
    }
</PRE>
<P>
You can also block until a specified event occurs. The function
<TT>pthread_cond_timedwait()</TT> is used for this purpose. It is  prototyped by:
<P><PRE>
int pthread_cond_timedwait(pthread_cond_t *cv,
      pthread_mutex_t *mp, const struct timespec *abstime);
</PRE>
<P><TT>pthread_cond_timedwait()</TT> is used in a similar manner to <TT>
pthread_cond_wait()</TT>: <TT>pthread_cond_timedwait()</TT>  blocks
until the condition is signaled or until the time of day, specified by <TT>abstime</TT>,
has passed. <TT>pthread_cond_timedwait()</TT> always returns with the mutex, <TT>mp</TT>,
locked and owned by the calling thread, even when it is returning an error. <TT>
pthread_cond_timedwait()</TT> is also a cancellation point.
<P><TT>pthread_cond_timedwait()</TT> returns zero after completing successfully. Any other
returned value indicates that an error occurred. When either of the following
conditions occurs, the function fails and returns the corresponding value.
<P>
An examle  call of this function is:
<P><PRE>
#include &lt;pthread.h&gt; 
#include &lt;time.h&gt; 

pthread_timestruc_t to;
pthread_cond_t cv; 
pthread_mutex_t mp;
timestruct_t abstime; 
int ret; 

/* wait on condition variable */ 

ret = pthread_cond_timedwait(&amp;cv, &amp;mp, &amp;abstime);


pthread_mutex_lock(&amp;m); 
to.tv_sec = time(NULL) + TIMEOUT; 
to.tv_nsec = 0; 

while (cond == FALSE) 
  {  err = pthread_cond_timedwait(&amp;c, &amp;m, &amp;to); 
     if (err == ETIMEDOUT) 
       { /* timeout, do something */ 
         break; 
       } 
   } 
pthread_mutex_unlock(&amp;m);
</PRE>
<P>
All threads may be unblocked in one function: <TT>pthread_cond_broadcast()</TT>.
This function is prototyped as follows:
<P><PRE>
int pthread_cond_broadcast(pthread_cond_t *cv);
</PRE>
<P><TT>pthread_cond_broadcast()</TT> unblocks
all threads that are blocked on the condition variable pointed to by <TT>cv</TT>, specified
by <TT>pthread_cond_wait()</TT>. When no threads are blocked on the condition variable,
<TT>pthread_cond_broadcast()</TT> has no effect.
<P><TT>pthread_cond_broadcast()</TT>
returns zero after completing successfully. Any other returned value indicates that an
error occurred. When the following condition occurs, the function fails and returns the
corresponding value.
<P>
Since
<TT>pthread_cond_broadcast()</TT> causes all threads blocked on the condition to contend
again for the mutex lock, use carefully. For example, use <TT>
pthread_cond_broadcast()</TT> to allow threads to contend for varying resource amounts
when resources are freed:
<P><PRE>
#include &lt;pthread.h&gt;

pthread_mutex_t rsrc_lock; 
pthread_cond_t rsrc_add;
unsigned int resources; 

get_resources(int amount) 
  { pthread_mutex_lock(&amp;rsrc_lock);
    while (resources &lt; amount) 
       pthread_cond_wait(&amp;rsrc_add, &amp;rsrc_lock); 
        
   resources -= amount; 
   pthread_mutex_unlock(&amp;rsrc_lock); 
  } 

add_resources(int amount) 
  { pthread_mutex_lock(&amp;rsrc_lock); 
    resources += amount;
    pthread_cond_broadcast(&amp;rsrc_add); 
    pthread_mutex_unlock(&amp;rsrc_lock); 
  }
</PRE>
<P><B>Note:</B> that in
<TT>add_resources</TT> it does not matter whether resources is updated first or if
<TT>pthread_cond_broadcast()</TT> is called first inside the mutex lock. Call
<TT>pthread_cond_broadcast()</TT> under the protection of the same mutex that is used
with the condition variable being signaled. Otherwise, the condition variable could be
signaled between the test of the associated condition and blocking in
<TT>pthread_cond_wait()</TT>, which can cause an infinite wait.
<P><H2><A NAME="SECTION003126000000000000000">
Destroying a  Condition Variable State</A>
</H2>
<P>
The function <TT>pthread_cond_destroy()</TT> to destroy any state associated with the
condition variable, it is prototyped by:
<P><PRE>
int pthread_cond_destroy(pthread_cond_t *cv);
</PRE>
<P>
The condition variable pointed to by <TT>cv</TT> will be destroyed by this call:
<P><PRE>
#include &lt;pthread.h&gt; 

pthread_cond_t cv; 
int ret; 

/* Condition variable is destroyed */ 
ret = pthread_cond_destroy(&amp;cv);
</PRE>
<P><B>Note</B> that the space for storing the
condition variable is not freed.
<P><TT>pthread_cond_destroy()</TT> returns zero after
completing successfully. Any other returned value indicates that an error occurred.
When any of the following conditions occur, the function fails and returns the
corresponding value.
<P><H2><A NAME="SECTION003127000000000000000">
Solaris Condition Variables</A>
</H2>
<P>
Similar
 condition variables exist in Solaris. The functions are prototyped in
&lt;thread.h&gt;.
<P>
To initialize a condition variable use 
<TT>int cond_init(cond_t *cv, int type, int arg)</TT> which  initializes the condition
variable pointed to by <TT>cv</TT>. The <TT>type</TT> can be one of <TT>USYNC_PROCESS</TT> or  
<TT>USYNC_THREAD</TT> (See Solaris mutex (Section&nbsp;<A HREF="node31.html#sec:sol_mutex">30.1.9</A> for more details).
Note that <TT>arg</TT> is currently ignored.
<P>
Condition variables
can also be initialized by allocation in zeroed memory, in which case a type of
<TT>USYNC_THREAD</TT> is assumed. Multiple threads must not initialize the same condition
variable simultaneously. A condition variable must not be reinitialized while other
threads might be using it.
<P>
To destroy a condition variable use <TT>int cond_destroy(cond_t *cv)</TT>
which destroys a state associated with the condition variable pointed to by
<TT>cv</TT>. The space for storing the condition variable is not freed.
<P>
To wait for a
condition use <TT>int cond_wait(cond_t *cv, mutex_t *mp)</TT> which atomically releases
the mutex pointed to by <TT>mp</TT> and to cause the calling thread to block on the
condition variable pointed to by <TT>cv</TT>.
<P>
The blocked thread can be awakened by <TT>cond_signal(cond_t *cv)</TT>,
<TT>cond_broadcast(cond_t *cv)</TT>, or when interrupted by delivery of a signal or a
fork. Use <TT>cond_signal()</TT> to unblock one thread that is blocked on the condition
variable pointed to by <TT>cv</TT>. Call this function under protection of the same mutex
used with the condition variable being signaled. Otherwise, the condition could be
signaled between its test and <TT>cond_wait()</TT>, causing an infinite wait. Use <TT>
cond_broadcast()</TT> to unblock all threads that are blocked on the condition variable
pointed to by <TT>cv</TT>. When no threads are blocked on the condition variable then
<TT>cond_broadcast()</TT> has no effect.
<P>
Finally, to wait until the condition is signaled or for
an absolute time use <TT>int cond_timedwait(cond_t *cv,
mutex_t *mp, timestruct_t abstime)</TT>  Use <TT>cond_timedwait()</TT> as you would use
<TT>cond_wait()</TT>, except that <TT>cond_timedwait()</TT> does not block past the time of
day specified by abstime. <TT>cond_timedwait()</TT> always returns with the mutex locked
and owned by the calling thread even when returning an error.
<P><H1><A NAME="SECTION003130000000000000000">
Threads and Semaphores</A>
</H1>
<A NAME="ch:thread_sem">&#160;</A>
<H2><A NAME="SECTION003131000000000000000">
POSIX Semaphores</A>
</H2>
<P>
Chapter&nbsp;<A HREF="node26.html#ch:semaphores">25</A> has dealt with semaphore programming for POSIX and System V
IPC semaphores.
<P>
Semaphore operations are the same in both POSIX and Solaris. The function
names are changed from  <TT>sema_</TT> in Solaris to <TT>sem_</TT> in pthreads. Solaris
semaphore are defined in &lt;thread.h&gt;.
<P>
In this section we give a brief description of Solaris thread semaphores.
<P><H2><A NAME="SECTION003132000000000000000">
Basic Solaris Semaphore Functions</A>
</H2>
<P>
To initialize the function <TT>int sema_init(sema_t *sp, unsigned int count,
int type, void *arg)</TT> is used. <TT>sema</TT>. <TT>type</TT> can be one of the following 
):
<P><DL>
<DT><STRONG><TT>USYNC_PROCESS</TT></STRONG>
<DD>--  The semaphore can be used to
synchronize threads in this process and other processes. Only one process should
initialize the semaphore.
<DT><STRONG><TT>USYNC_THREAD</TT></STRONG>
<DD>-- The semaphore can be used to
synchronize threads in this process.
</DL>
<P><TT>arg </TT> is currently unused.
<P>
Multiple threads <B>must not</B>
initialize the same semaphore simultaneously. A semaphore <B>must not</B> be
reinitialized while other threads may be using it.
<P>
To increment a Semaphore use the function <TT>int sema_post(sema_t *sp)</TT>. <TT>
sema_post</TT> atomically increments the semaphore pointed to by <TT>sp</TT>. When any threads
are blocked on the semaphore, one is unblocked.
<P>
To block on a Semaphore use <TT>int sema_wait(sema_t *sp)</TT>. <TT>sema_wait()</TT> to
block the calling thread until the count in the semaphore pointed to by <TT>sp</TT> becomes
greater than zero, then atomically decrement it.
<P>
To decrement a Semaphore count use <TT>int sema_trywait(sema_t *sp)</TT>. <TT>
sema_trywait()</TT>  atomically decrements the count in the semaphore pointed to by <TT>
sp</TT> when the count is greater than zero. This function is a nonblocking version of
<TT>sema_wait()</TT>.
<P>
To destroy the Semaphore state call the function <TT>
sema_destroy(sema_t *sp)</TT>. <TT>sema_destroy()</TT> to
destroy any state associated with the semaphore pointed to by <TT>sp</TT>. The space for
storing the semaphore is not freed.
<P>
<BR><HR>
<ADDRESS>
<I>Dave Marshall</I>
<BR><I>1/5/1999</I>
</ADDRESS>
</BODY>

<!-- Mirrored from users.cs.cf.ac.uk/Dave.Marshall/C/node31.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 Oct 2020 09:07:24 GMT -->
</HTML>
